the sun2 mainbus signal handler needs to OR together like signals from
the different buses; right now the state of a signal on the mainbus is
just the state of the signal on the last bus that happened to call it
out.  this will cause interrupts to get lost (but because of cooperative
threading, this probably isn't manifesting now).

fix thread dispatch problems when not using gtk

clean up posix-serial callouts to be like 3c400

is the (brief) extension word handling correct for PC-relative 
EAs when there are multiple brief extension words?  (i.e., is 
first_ea_extword_offset updated (does it need to be?))

in type 8 frames, we currently store the address as it appeared
on the bus - i.e., only 24 bits, not the full 32.  maybe this is
incorrect?

should tme_m68k_rte_start have more RESTARTING checks?

are the data input buffer and data output buffers being kept in the
right endianness in both the trap frames and in the ic buffers?

watch out for (raw[0] << 4) possibly staying 8-bit and then overflowing
in tme_m68k_insn_buffer_xfer

optimization: have the fast executor only execute an instruction if
there are TME_M68K_INSN_WORDS_MAX * sizeof(tme_uint16_t) bytes
available.  note that this does *not* eliminate the need for the
group0 hook entirely, since while we guarantee that we won't fault on
an instruction fetch, we still might fault on data in
mid-instruction-fetch.  this optimization would however remove a 
test and goto in the fast FETCH macros.

probably the way ENA_NONBOOT works on the sun2 is that all FC_SP
references go to the PROM

/* version enforcement: */
#if !defined(TME_BUS_DEVICE_VERSION) || TME_VERSION_CURRENT_X(TME_BUS_DEVICE_VERSION) != 0
#error "check your sources; <tme/bus-device.h> version is now 0"
#endif

/* includes: */
#include <tme/element.h>
#undef TME_BUS_VERSION
#define TME_BUS_VERSION TME_VERSION_X(0, 0, 0)
#include <tme/generic/bus.h>

sun-sc's slow cycle implementation is broken; it should use the new
bus-device dma support

if a tlb_fill function invalidates previous TLBs, make sure that it
invalidates before it fills (since it may be filling the same
structure it wants to invalidate.)

m68k: lowering the interrupt priority mask below 7 when the external
priority is 7 causes another NMI to be recognized.

TLBs filled for DVMA space for the VME bus shouldn't refer to the
obmem bus fault handler, right?

file a PR against NetBSD/sun3 1.6.x:
sys/arch/sun3/dev/if_ie.c:ie_readframe(), when NBPFILTER == 0, calls
ieget() with NULL for its int *to_bpf argument.  this ultimately
causes a NULL dereference in (the inline expansion of) check_eh() -
witness a "clrl 0" instruction in the compiler output for
ie_readframe().  proper fix is to remove the *to_bpf = 0 in check_eh().

file a PR against NetBSD/sun3:
XXX FIXME - this hack works around a bug in NetBSD/sun3, present
since revision 1.49 of src/sys/arch/sun3/conf/GENERIC (when the
sun3x port was merged into the sun3 port).  in this revision, the
declaration for cgtwo0 changed:

-cgtwo0 at vmes0 addr 0xff400000 level 4 vect 0xA8
+cgtwo0 at vme2 addr 0x400000 ipl 4 vect 0xA8

because the cg2mmap() function in src/sys/arch/sun3/dev/cg2.c
doesn't add the 0xff000000 mask to the configured physical
address (needed because the cgtwo is an A24 device), when Xsun
mmap()s the cgtwo it gets a mapping of physical address 0x400000
in VME space instead of the correct 0xff400000.  the sparc cgtwo
driver gets this right.

- bus: DRQ(x) and DACK(x), with an UNSPEC
- ncr5380: bug where a SCSI callout deferred because of a higher-priority callout isn't put into later_callouts

in ncr5380.c:_tme_ncr5380_bus_tlb_fill(), the structure assignment
of *tlb from *ncr5380->tme_ncr5380_dma_tlb may copy fields partially
and/or out-of-order, such that the subsequent relevance test succeeds
when it should fail?  we should probably test at least the important,
invalidating fields in *ncr5380->tme_ncr5380_dma_tlb instead of the
local *tlb?  XXX actually, ncr5380.c needs to use the new TLB
valid/invalid tests, and be made more thread-safe.

in ncr5380.c:_tme_ncr5380_scsi_cycle(), we test if tme_scsi_dma_in
points to the internal FIFO to determine if the transfer was a read;
however, if the transfer was a write this value may be garbage (under
NDEBUG, it isn't initialized in _tme_ncr5380_callout()) that happens
to match the internal FIFO anyways.

the SCSI DMA structure needs to be expanded to support tme_shared
pointers and bus boundary values, and scsi-bus.c needs to use
tme_memory_bus_read_buffer(), tme_memory_bus_write_buffer() as
appropriate.

make sure all callers of *_tlb_allocate have tme_shared tlb set pointers

need barriers in the m68k read/write/fetch, etc. functions

remove the locks argument from the generic bus-device DMA functions, since
elements are only supposed to have a single mutex (and provide a pointer
to the mutex in the struct tme_bus_device, or maybe have the mutex in the
struct tme_bus_device).

sun4: log when cache and memerr become visible/invisible
sun4: log when FPU compliance changes

bus-device-auto.sh: keep bus router from device structure in a local,
in case it gets changed during a callout

ncr53c9x: the SS2 esp is really an ESP100A, not an ESP100.

sparc: for long-lived idle types, print address when first detected

sparc: most unimplemented instructions cause NULL dereferences from opcode table

gtk-keyboard.c: some X servers actually *don't* give locking behavior
to the Caps_Lock, Num_Lock, etc., keysyms, and this causes problems.
see the comments in _tme_gtk_keyboard_x11_new().

sun4: FAILURE: SEVAR (60000004) Power-Up, Exp = 00000000, Obs = ffed9000

sparc: is the test "x${sign}" = xs in sparc-insns-auto.sh right?
