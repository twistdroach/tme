#! /bin/sh

# $Id: m68k-insns-auto.sh,v 1.19 2003/05/16 21:48:11 fredette Exp $

# ic/m68k/m68k-insns-auto.sh - automatically generates C code 
# for many m68k emulation instructions:

#
# Copyright (c) 2002, 2003 Matt Fredette
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#      This product includes software developed by Matt Fredette.
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

header=false

for option
do
    case $option in
    --header) header=true ;;
    esac
done

PROG=`basename $0`
cat <<EOF
/* automatically generated by $PROG, do not edit! */
_TME_RCSID("\$Id: m68k-insns-auto.sh,v 1.19 2003/05/16 21:48:11 fredette Exp $");

EOF
if $header; then :; else
    cat <<EOF
#include "m68k-impl.h"

EOF
fi

# permute for the three different operand sizes we need to handle:
for size in 8 16 32; do
    
    # the shifts needed to get register contents of a specific size:
    case ${size} in
    8)  reg_size_shift=' << 2' ;;
    16) reg_size_shift=' << 1' ;;
    32) reg_size_shift='' ;;
    esac

    # generate the ALU functions:
    for name in add sub cmp neg or and eor not tst move moveq clr cmpa negx addx subx cmpm; do

	# characterize each operation:
	optype=normal ; src=op0 ; dst=op1 ; res=op1 ; arith=no ; with_x=false ; store_res=true
	case "$name" in
	add) op=' + ' ; arith=add ;;
	sub) op=' - ' ; arith=sub ;;
	cmp) op=' - ' ; arith=sub ; store_res=false ;;
	neg) op=' - ' ; arith=sub ; dst=0 ; src=op1 ;;
	or)  op=' | ' ;;
	and) op=' & ' ;;
	eor) op=' ^ ' ;;
	not) op='~ ' ; dst= ; src=op1 ;;
	tst) op='' ; dst= ; src=op1 ; store_res=false ;;
	move) op='' ; dst= ; src=op1 ; res=op0 ;;
	moveq) op='' ; dst= ; src=opc8 ; if test ${size} != 32; then continue; fi ;;
	clr) op='' ; dst= ; src=0 ;; 
	cmpa) op=' - ' ; arith=sub ; src=op0.16s32 ; store_res=false
	    if test $size != 16; then continue; fi ;;
	negx) op=' - ' ; arith=sub ; with_x=true ; dst=0 ; src=op1 ;;
	addx) op=' + ' ; arith=add ; optype=mathx ; with_x=true ;;
	subx) op=' - ' ; arith=sub ; optype=mathx ; with_x=true ;;
	cmpm) op=' - ' ; arith=sub ; optype=mathx ; store_res=false ;;
	*) echo "$0 internal error: unknown ALU function $name" 1>&2 ; exit 1 ;;
	esac

	# placeholder for another permutation:
	:

	    # if we're making the header, just emit a declaration:
	    if $header; then
		echo "TME_M68K_INSN_DECL(tme_m68k_${name}${size});"
		continue
	    fi

	    # open the function:
	    echo ""
	    echo -n "/* this does a ${size}-bit \"$name "
	    case "${src}/${dst}" in *op0*) echo -n "SRC, " ;; esac
	    echo "DST\": */"
	    echo "TME_M68K_INSN(tme_m68k_${name}${size})"
	    echo "{"

	    # declare our locals:
	    if test $name = cmpa; then size=32; fi
	    echo -n "  tme_uint${size}_t res"
	    case "${src}/${dst}" in *op0*) echo -n ", op0" ;; esac
	    case "${src}/${dst}" in *op1*) echo -n ", op1" ;; esac
	    echo ";"
	    echo "  tme_uint8_t flags;"

	    # load the operand(s):
	    echo ""
	    echo "  /* load the operand(s): */"
	    case ${optype} in
	    mathx)
		echo "  unsigned int function_code = TME_M68K_FUNCTION_CODE_DATA(ic);"

		# NB: in my 68000 Programmer's Manual, the description
		# of subx is a little backwards from addx and cmpm. in
		# subx, the reg field at bits 0-2 is called the "x"
		# field, where in addx and cmpm it's called the "y"
		# field, and similarly for the reg field at bits 9-11.
		# fortunately, the meanings of the two reg fields is
		# always the same despite this - the reg field at bits
		# 0-2 always identifies the source operand, and the
		# reg field at bits 9-11 always identifies the
		# destination operand:
		echo "  int ireg_src = TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 0, 3);"
		echo "  int ireg_dst = TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 9, 3);"

		# the stack pointer must always be adjusted by a multiple of two.
		# assuming ireg < 8, ((ireg + 1) >> 3) == 1 iff ireg == 7, meaning %a7:
		echo -n "  tme_uint32_t ireg_src_adjust = sizeof(tme_uint${size}_t)";
		if test ${size} = 8; then
		    echo -n " + ((ireg_src + 1) >> 3)"
		fi
		echo ";"
		echo -n "  tme_uint32_t ireg_dst_adjust = sizeof(tme_uint${size}_t)";
		if test ${size} = 8; then
		    echo -n " + ((ireg_dst + 1) >> 3)"
		fi
		echo ";"

		case ${name} in

		# cmpm always uses memory and is always postincrement:
		cmpm)
		    echo ""
		    echo "  TME_M68K_INSN_CANFAULT;"
		    echo ""
		    echo "  if (!TME_M68K_SEQUENCE_RESTARTING) {"
		    echo "    ic->_tme_m68k_ea_function_code = function_code;"
		    echo "    ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_dst);"
		    echo "    ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_dst) += ireg_dst_adjust;"
		    echo "  }"
		    echo "  tme_m68k_read_memx${size}(ic);"
		    echo "  if (!TME_M68K_SEQUENCE_RESTARTING) {"
		    echo "    ic->_tme_m68k_ea_function_code = function_code;"
		    echo "    ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_src);"
		    echo "    ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_src) += ireg_src_adjust;"
		    echo "  }"
		    echo "  tme_m68k_read_mem${size}(ic, TME_M68K_IREG_MEMY${size});"
		    echo "  ${dst} = ic->tme_m68k_ireg_memx${size};"
		    echo "  ${src} = ic->tme_m68k_ireg_memy${size};"
		    ;;

		# addx and subx use either registers or memory.  if they use memory,
		# they always predecrement:
		addx|subx)
		    echo "  tme_uint16_t memory;"
		    echo ""
		    echo "  memory = (TME_M68K_INSN_OPCODE & TME_BIT(3));"
		    echo "  if (memory) {"
		    echo "    TME_M68K_INSN_CANFAULT;"
		    echo "    if (!TME_M68K_SEQUENCE_RESTARTING) {"
		    echo "      ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_dst) -= ireg_dst_adjust;"
		    echo "      ic->_tme_m68k_ea_function_code = function_code;"
		    echo "      ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_dst);"
		    echo "    }"
		    echo "    tme_m68k_read_memx${size}(ic);"
		    echo "    if (!TME_M68K_SEQUENCE_RESTARTING) {"
		    echo "      ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_src) -= ireg_src_adjust;"
		    echo "      ic->_tme_m68k_ea_function_code = function_code;"
		    echo "      ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_src);"
		    echo "    }"
		    echo "    tme_m68k_read_mem${size}(ic, TME_M68K_IREG_MEMY${size});"
		    echo "    ${dst} = ic->tme_m68k_ireg_memx${size};"
		    echo "    ${src} = ic->tme_m68k_ireg_memy${size};"
		    echo "  }"
		    echo "  else {"
		    echo "    ${src} = ic->tme_m68k_ireg_uint${size}((TME_M68K_IREG_D0 + ireg_src)${reg_size_shift});"
		    echo "    ${dst} = ic->tme_m68k_ireg_uint${size}((TME_M68K_IREG_D0 + ireg_dst)${reg_size_shift});"
		    echo "  }"
		    ;;
		*) echo "$0 internal error: unknown mathx ${name}" 1>&2 ; exit 1 ;;
		esac
		;;
	    normal)
		for which in src dst; do
		    eval 'what=$'${which}
		    case "x${what}" in
		    x|x0) ;;
		    xop[01].16s32)
			what=`echo ${what} | sed -e 's/\..*//'`
			eval ${which}"=${what}"
			echo "  ${what} = (tme_uint32_t) ((tme_int32_t) *((tme_int16_t *) _${what}));"
			;;
		    xop[01])
			echo "  ${what} = *((tme_uint${size}_t *) _${what});"
			;;
		    xopc8)
		        eval ${which}"='TME_EXT_S8_U${size}((tme_int8_t) (TME_M68K_INSN_OPCODE & 0xff))'"
			;;
		    *) echo "$0 internal error: unknown what ${what}" 1>&2 ; exit 1 ;;
		    esac
		done
		;;
	    *) echo "$0 internal error: unknown optype ${optype}" 1>&2 ; exit 1 ;;
	    esac

	    # perform the operation:
	    echo ""
	    echo "  /* perform the operation: */"
	    echo -n "  res = ${dst}${op}${src}"
	    if $with_x; then
		echo -n "${op}((ic->tme_m68k_ireg_ccr / TME_M68K_FLAG_X) & 1)"
	    fi
	    echo ";"

	    # store the result:
	    if $store_res; then
		echo ""
		echo "  /* store the result: */"
		case ${optype} in
		mathx)
		    echo "  if (memory) {"
		    echo "    if (!TME_M68K_SEQUENCE_RESTARTING) {"
		    echo "      ic->tme_m68k_ireg_memx${size} = res;"
		    echo "      ic->_tme_m68k_ea_function_code = function_code;"
		    echo "      ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ireg_dst);"
		    echo "    }"
		    echo "    tme_m68k_write_memx${size}(ic);"
		    echo "  }"
		    echo "  else {"
		    echo "    ic->tme_m68k_ireg_uint${size}((TME_M68K_IREG_D0 + ireg_dst)${reg_size_shift}) = res;"
		    echo "  }"
		    ;;
		normal)
		    echo "  *((tme_uint${size}_t *) _${res}) = res;"
		    ;;
		*) echo "$0 internal error: unknown optype ${optype}" 1>&2 ; exit 1 ;;
		esac
	    fi

	    # start the status flags, maybe preserving X:
	    echo ""
	    echo "  /* set the flags: */"
	    case "${name}:${arith}" in
	    cmp*|*:no)
		flag_x=
		;;
	    *)
		flag_x=" | TME_M68K_FLAG_X"
		;;
	    esac

	    # set N.  we cast to tme_uint8_t as soon as we know the
	    # bit we want is within the range of the type, to try
	    # to affect the generated assembly:
	    echo "  flags = ((tme_uint8_t) (((tme_uint${size}_t) res) >> (${size} - 1))) * TME_M68K_FLAG_N;"
	    
	    # set Z:
	    if $with_x; then
		echo "  if (res == 0) flags |= (ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_Z);"
	    else
		echo "  if (res == 0) flags |= TME_M68K_FLAG_Z;"
	    fi

	    # set V and C and maybe X:
	    case $arith in
	    add)
		case $size in
		8) ones="0xff" ;;
		16) ones="0xffff" ;;
		32) ones="0xffffffff" ;;
		esac
		# if the operands are the same sign, and the result has
	        # a different sign, set V.   we cast to tme_uint8_t as 
		# soon as we know the bit we want is within the range 
		# of the type, to try to affect the generated assembly:
		echo "  flags |= ((tme_uint8_t) (((${src} ^ ${dst} ^ ${ones}) & (${dst} ^ res)) >> (${size} - 1))) * TME_M68K_FLAG_V;"
		# if src is greater than the logical inverse of dst, set C:
		echo -n "  if (${src} > (${dst} ^ ${ones})"
		if $with_x; then
		    echo -n " || (${src} == (${dst} ^ ${ones}) && (ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_X))"
		fi
		echo ") flags |= TME_M68K_FLAG_C${flag_x};"
		;;
	    sub) 
		# if the operands are different signs, and the result has
	        # a different sign from the first operand, set V.  we
		# cast to tme_uint8_t as soon as we know the bit we want
		# is within the range of the type, to try to affect the
		# generated assembly:
		echo "  flags |= ((tme_uint8_t) (((${src} ^ ${dst}) & (${dst} ^ res)) >> (${size} - 1))) * TME_M68K_FLAG_V;"
		# if src is greater than dst, set C:
		echo -n "  if (${src} > ${dst}"
		if $with_x; then
		    echo -n " || (${src} == ${dst} && (ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_X))"
		fi
		echo ") flags |= TME_M68K_FLAG_C${flag_x};"
		;;
	    no) ;;
	    esac

	    # preserve X:
	    if test "x${flag_x}" = x; then
		echo "  flags |= (ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_X);"
	    fi

	    # set the flags:
	    echo "  ic->tme_m68k_ireg_ccr = flags;"
	    
	    # done:
	    echo ""
	    echo "  TME_M68K_INSN_OK;"
	    echo "}"

	    if test $name = cmpa; then size=16; fi
    done

    # generate the address math functions:
    for name in suba adda movea; do

	# the address math functions don't need an 8-bit version:
	if test $size = 8; then continue; fi

	# if we're making the header, just emit a declaration:
	if $header; then
	    echo "TME_M68K_INSN_DECL(tme_m68k_${name}${size});"
	    continue
	fi

	echo ""
	echo "/* the ${name} function on a ${size}-byte EA: */"
	echo "TME_M68K_INSN(tme_m68k_${name}${size})"
	echo "{"
	case $name in
	suba) op='-' ; src="_op0" ; dst="_op1" ;;
	adda) op='+' ; src="_op0" ; dst="_op1" ;;
	movea) op='' ; src="_op1" ; dst="_op0" ;;
	esac
	echo "  *((tme_int32_t *) ${dst}) ${op}= *((tme_int${size}_t *) ${src});"
	echo "  TME_M68K_INSN_OK;"
	echo "}"
    done
	    
    # generate the bit functions:
    for name in btst bchg bclr bset; do
	
	# the bit functions don't need a 16-bit version:
	if test $size = 16; then continue; fi

	# if we're making the header, just emit a declaration:
	if $header; then
	    echo "TME_M68K_INSN_DECL(tme_m68k_${name}${size});"
	    continue
	fi

	echo ""
	echo "/* the ${name} function on a ${size}-byte EA: */"
	echo "TME_M68K_INSN(tme_m68k_${name}${size})"
	echo "{"
	echo "  tme_uint${size}_t value, bit;"
	echo "  bit = _TME_BIT(tme_uint${size}_t, TME_M68K_INSN_OP0(tme_uint8_t) & (${size} - 1));"
	echo "  value = TME_M68K_INSN_OP1(tme_uint${size}_t);"
	echo "  if (value & bit) {"
	echo "    ic->tme_m68k_ireg_ccr &= ~TME_M68K_FLAG_Z;"
	echo "  }"
	echo "  else {"
	echo "    ic->tme_m68k_ireg_ccr |= TME_M68K_FLAG_Z;"
	echo "  }"
	case ${name} in
	btst) ;;
	bchg) echo "  TME_M68K_INSN_OP1(tme_uint${size}_t) = value ^ bit;" ;;
	bclr) echo "  TME_M68K_INSN_OP1(tme_uint${size}_t) = value & ~bit;" ;;
	bset) echo "  TME_M68K_INSN_OP1(tme_uint${size}_t) = value | bit;" ;;
	esac
	echo "  TME_M68K_INSN_OK;"
	echo "}"
    done

    # generate the shift/rotate functions:
    for func in as ls ro rox; do
	for dir in l r; do
	    name="${func}${dir}"

	    # if we're making the header, just emit a declaration:
	    if $header; then
		echo "TME_M68K_INSN_DECL(tme_m68k_${name}${size});"
		continue
	    fi

	    echo ""
	    echo "/* the ${name} function on a ${size}-byte EA: */"
	    echo "TME_M68K_INSN(tme_m68k_${name}${size})"
	    echo "{"
	    echo "  unsigned int count;"
	    sign=u
	    case "${name}" in
	    asr) sign= ;;
	    asl) echo "  tme_uint${size}_t sign_bits;" ;;
	    rox[lr]) echo "  tme_uint8_t xbit;" ;;
	    *) ;;
	    esac
	    echo "  tme_${sign}int${size}_t res;"
	    echo "  tme_uint8_t flags;"
	    echo ""
	    echo "  /* get the count and operand: */"
	    echo "  count = TME_M68K_INSN_OP0(tme_uint8_t) & 63;"
	    echo "  res = TME_M68K_INSN_OP1(tme_${sign}int${size}_t);"

	    echo ""
	    echo "  /* generate the X, V, and C flags assuming the count is zero: */"
	    echo "  flags = ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_X;"
	    case "${name}" in
	    rox[lr])
		echo "  xbit = (flags / TME_M68K_FLAG_X);"
		echo "  flags |= (xbit * TME_M68K_FLAG_C);"
		;;
	    esac

	    echo ""
	    echo "  /* if the count is nonzero, update the result and"
	    echo "     generate the X, V, and C flags: */"
	    echo "  if (count > 0) {"
	    case "${name}" in
	    [al]sr)
		echo "    if (63 > SHIFTMAX_INT${size}_T"
		echo "        && count > ${size}) {"
		echo "      res = 0;"
		echo "    }"
		echo "    res >>= (count - 1);"
		echo "    flags = (res & 1);"
		echo "    flags *= TME_M68K_FLAG_C;"
		echo "    flags |= (flags * TME_M68K_FLAG_X);"
		echo "    res >>= 1;"
		;;
	    [al]sl)
		if test ${name} = asl; then
		    echo ""
		    echo "    /* we need to see how the sign of the result will change during"
		    echo "       shifting in order to generate V."
		    echo ""
		    echo "       in general, the idea is to get all of the bits that will ever"
		    echo "       appear in the sign position into sign_bits; if sign_bits is"
		    echo "       all-bits-one or all-bits zero, clear V, else set V.  a good trick"
		    echo "       is that ((sign_bits + 1) & sign_bits) is nonzero iff all of the"
		    echo "       bits in sign_bits are the same."
		    echo ""
		    echo "       start by loading all of the operand into sign_bits."
		    echo ""
		    echo "       if the shift count is exactly ${size} - 1, then all of the bits"
		    echo "       of the operand will appear in the sign position."
		    echo ""
		    echo "       if the shift count is less than ${size} - 1, then some of the"
		    echo "       less significant bits of the operand will never appear in the"
		    echo "       sign position, so we can shift them off of sign_bits now."
		    echo ""
		    echo "       if the shift count is greater than ${size} - 1, then all of the"
		    echo "       bits in the operand, plus at least one zero bit, will appear in"
		    echo "       the sign position.  the only way that the sign bit will never"
		    echo "       change during the shift is if the operand was zero to begin with."
		    echo "       we need to change sign_bits such that ((sign_bits + 1) &"
		    echo "       sign_bits) will be zero iff the operand was zero to begin with."
		    echo "       the magic below does just that: */"
		    echo "    sign_bits = res;"
		fi
		echo "    if (63 > SHIFTMAX_INT${size}_T"
		echo "        && count > ${size}) {"
		echo "      res = 0;"
		echo "    }"
		echo "    res <<= (count - 1);"
		echo "    flags = (res >> (${size} - 1));"
		echo "    flags *= TME_M68K_FLAG_C;"
		echo "    flags |= (flags * TME_M68K_FLAG_X);"
		echo "    res <<= 1;"
		if test ${name} = asl; then		
		    echo "    if (count != ${size} - 1) {"
		    echo "      if (count < ${size}) {"
		    echo "        sign_bits >>= ((${size} - 1) - count);"
		    echo "      }"
		    echo "      else {"
		    echo "        sign_bits |= (sign_bits << 1);"
		    echo "        sign_bits &= -2;"
		    echo "      }"
		    echo "    }"		    
		    echo "    if ((sign_bits + 1) & sign_bits) {"
		    echo "      flags |= TME_M68K_FLAG_V;"
		    echo "    }"
		fi
		;;
	    ro[lr])
		echo "    count &= (${size} - 1);"
		if test $dir = l; then
		    echo "    res = (res << count) | (res >> (${size} - count));"
		    echo "    flags |= ((res & 1) * TME_M68K_FLAG_C);"
		else
		    echo "    res = (res << (${size} - count)) | (res >> count);"
		    echo "    flags |= ((res >> (${size} - 1)) * TME_M68K_FLAG_C);"
		fi
		;;
	    rox[lr])
		echo "    count %= (${size} + 1);"
		echo "    flags = xbit;"
		echo "    if (count > 0) {"
		if test $dir = l; then
		    echo "      flags = (res >> (${size} - count)) & 1;"
		    echo "      if (${size} > SHIFTMAX_INT${size}_T"
		    echo "          && count == ${size}) {"
		    echo "        res = 0 | (xbit << (${size} - 1)) | (res >> ((${size} + 1) - ${size}));"
		    echo "      }"
		    echo "      else if (${size} > SHIFTMAX_INT${size}_T"
		    echo "               && count == 1) {"
		    echo "        res = (res << 1) | (xbit << (1 - 1)) | 0;"
		    echo "      }"
		    echo "      else {"
		    echo "        res = (res << count) | (xbit << (count - 1)) | (res >> ((${size} + 1) - count));"
		    echo "      }"
		else
		    echo "      flags = (res >> (count - 1)) & 1;"
		    echo "      if (${size} > SHIFTMAX_INT${size}_T"
		    echo "          && count == ${size}) {"
		    echo "        res = (res << ((${size} + 1) - ${size})) | (xbit << (${size} - ${size})) | 0;"
		    echo "      }"
		    echo "      else if (${size} > SHIFTMAX_INT${size}_T"
		    echo "               && count == 1) {"
		    echo "        res = 0 | (xbit << (${size} - 1)) | (res >> 1);"
		    echo "      }"
		    echo "      else {"
		    echo "        res = (res << ((${size} + 1) - count)) | (xbit << (${size} - count)) | (res >> count);"
		    echo "      }"
		fi
		echo "    }"
		echo "    flags *= TME_M68K_FLAG_C;"
		echo "    flags |= (flags * TME_M68K_FLAG_X);"
		;;
	    esac
		echo "  }"

	    echo ""
	    echo "  /* store the result: */"
	    echo "  TME_M68K_INSN_OP1(tme_${sign}int${size}_t) = res;"

	    echo ""
	    echo "  /* generate the N flag.  we cast to tme_uint8_t as soon as we"
	    echo "     know the bit we want is within the range of the type, to try"
	    echo "     to affect the generated assembly: */"
	    echo "  flags |= ((tme_uint8_t) (((tme_uint${size}_t) res) >> (${size} - 1))) * TME_M68K_FLAG_N;"
	    
	    echo ""
	    echo "  /* generate the Z flag: */"
	    echo "  if (res == 0) flags |= TME_M68K_FLAG_Z;"

	    echo ""
	    echo "  /* store the flags: */"
	    echo "  ic->tme_m68k_ireg_ccr = flags;"
	    echo "  TME_M68K_INSN_OK;"
	    echo "}"
	done
    done

    # movep_rm, movep_mr, movem_rm, and movem_mr:
    for name in rm mr; do
    
	# movep and movem don't need 8-bit versions:
	if test ${size} = 8; then continue; fi

	# if we're making the header, just emit declarations:
	if $header; then
	    echo "TME_M68K_INSN_DECL(tme_m68k_movep_${name}${size});"
	    echo "TME_M68K_INSN_DECL(tme_m68k_movem_${name}${size});"
	    continue
	fi

	# emit the movep function:
	echo ""
	echo "/* the movep_${name} function on a ${size}-bit dreg: */"
	echo "TME_M68K_INSN(tme_m68k_movep_${name}${size})"
	echo "{"
	echo "  unsigned int function_code;"
	echo "  tme_uint32_t linear_address;"
	if test $name = rm; then
	    echo "  tme_uint${size}_t value;"
	fi
	echo "  int dreg;"
	echo ""
	echo "  TME_M68K_INSN_CANFAULT;"
	echo ""
	echo "  function_code = TME_M68K_FUNCTION_CODE_DATA(ic);"
	echo "  linear_address = TME_M68K_INSN_OP1(tme_uint32_t);"
	echo "  linear_address += (tme_int32_t) ((tme_int16_t) TME_M68K_INSN_SPECOP);"
	echo "  dreg = TME_M68K_IREG_D0 + TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 9, 3);"

	# set value:
	if test $name = rm; then
	    echo "  value = ic->tme_m68k_ireg_uint${size}(dreg${reg_size_shift});"
            value="value"
        else
            value="ic->tme_m68k_ireg_uint${size}(dreg${reg_size_shift})"
	fi
	
	# transfer the bytes:
	pos=${size}
	while test $pos != 0; do
	    pos=`expr ${pos} - 8`
	    echo "  if (!TME_M68K_SEQUENCE_RESTARTING) {"
	    echo "    ic->_tme_m68k_ea_function_code = function_code;"
	    echo "    ic->_tme_m68k_ea_address = linear_address;"
	    if test $name = rm; then
		echo "    ic->tme_m68k_ireg_memx8 = TME_FIELD_EXTRACTU(${value}, ${pos}, 8);"
		echo "  }"
		echo "  tme_m68k_write_memx8(ic);"
	    else
		echo "  }"
		echo "  tme_m68k_read_memx8(ic);"
		echo "  if (!TME_M68K_SEQUENCE_RESTARTING) {"
		echo "    TME_FIELD_DEPOSIT${size}(${value}, ${pos}, 8, ic->tme_m68k_ireg_memx8);"
		echo "  }"
	    fi
	    echo "  linear_address += 2;"
	done

	echo "  TME_M68K_INSN_OK;"
	echo "}"

	# emit the movem function:
	echo ""
	echo "/* the movem_${name} function on ${size}-bit registers: */"
	echo "TME_M68K_INSN(tme_m68k_movem_${name}${size})"
	echo "{"
	echo "  int ireg, direction;"
	echo "  tme_uint16_t mask, bit;"
	echo "  unsigned int ea_mode;"
	echo "  tme_uint32_t addend;"

	echo ""
	echo "  TME_M68K_INSN_CANFAULT;"
	echo ""
	echo "  /* figure out what direction to move in, and where to start from: */"
	echo "  ea_mode = TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 3, 3);"
	echo "  direction = 1;"
	echo "  ireg = TME_M68K_IREG_D0;"
	if test $name = rm; then
	    echo "  if (ea_mode == 4) {"
	    echo "    direction = -1;"
	    echo "    ireg = TME_M68K_IREG_A7;"
	    echo "    if (!TME_M68K_SEQUENCE_RESTARTING) {"
	    echo "      ic->_tme_m68k_ea_address -= sizeof(tme_uint${size}_t);"
	    echo "    }"
	    echo "  }"
	fi
	echo "  addend = (tme_uint32_t) (direction * sizeof(tme_uint${size}_t));"

	echo ""
	echo "  /* do the transfer: */"
	echo "  mask = TME_M68K_INSN_SPECOP;"
	echo "  for (bit = 1; bit != 0; bit <<= 1) {"
	echo "    if (mask & bit) {"
	if test $name = rm; then
	    echo "      if (!TME_M68K_SEQUENCE_RESTARTING) {"
	    echo "        ic->tme_m68k_ireg_memx${size} = ic->tme_m68k_ireg_uint${size}(ireg${reg_size_shift});"
	    echo "      }"
	    echo "      tme_m68k_write_memx${size}(ic);"
	    echo "      if (!TME_M68K_SEQUENCE_RESTARTING) {"
	else
	    echo "      tme_m68k_read_memx${size}(ic);"
	    echo "      if (!TME_M68K_SEQUENCE_RESTARTING) {"
	    echo -n "        ic->tme_m68k_ireg_uint32(ireg) = "
	    if test $size = 32; then
		echo "ic->tme_m68k_ireg_memx${size};"
	    else
		echo "TME_EXT_S${size}_U32((tme_int${size}_t) ic->tme_m68k_ireg_memx${size});"
	    fi
	fi
	echo "        ic->_tme_m68k_ea_address += addend;"
	echo "      }"
	echo "    }"
	echo "    ireg += direction;"
	echo "  }"
	echo ""

	# for the predecrement and postincrement modes, update the
	# address register:
	if test $name = rm; then 
	    echo "  /* if this is the predecrement mode, update the address register: */"
	    echo "  if (ea_mode == 4) {"
	    echo "    ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0"
	    echo "                              + TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 0, 3))"
	    echo "      = (ic->_tme_m68k_ea_address + sizeof(tme_uint${size}_t));"
	    echo "  }"
	else
	    echo "  /* if this is the postincrement mode, update the address register: */"
	    echo "  if (ea_mode == 3) {"
	    echo "    ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0"
	    echo "                              + TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 0, 3))"
	    echo "      = ic->_tme_m68k_ea_address;"
	    echo "  }"
	fi
	
	echo "  TME_M68K_INSN_OK;"
	echo "}"
    done

    # chk32 and chk16:
    if test $size != 8; then

	# if we're making the header, just emit a declaration:
	if $header; then
	    echo "TME_M68K_INSN_DECL(tme_m68k_chk${size});"
	else
	    echo ""
	    echo "/* chk${size}: */"
	    echo "TME_M68K_INSN(tme_m68k_chk${size})"
	    echo "{"
	    echo "  if (*((tme_int${size}_t *) _op0) < 0) {"
	    echo "    ic->tme_m68k_ireg_ccr |= TME_M68K_FLAG_N;"
	    echo "    ic->tme_m68k_ireg_pc = ic->tme_m68k_ireg_pc_next;"
	    echo "    TME_M68K_INSN_EXCEPTION(TME_M68K_EXCEPTION_GROUP2(6));"
	    echo "  }"
	    echo "  if (*((tme_int${size}_t *) _op0) > *((tme_int${size}_t *) _op1)) {"
	    echo "    ic->tme_m68k_ireg_ccr &= ~TME_M68K_FLAG_N;"
	    echo "    ic->tme_m68k_ireg_pc = ic->tme_m68k_ireg_pc_next;"
	    echo "    TME_M68K_INSN_EXCEPTION(TME_M68K_EXCEPTION_GROUP2(6));"
	    echo "  }"
	    echo "  TME_M68K_INSN_OK;"
	    echo "}"
	fi
    fi

    # cas and cas2:
    for name in cas cas2_; do
    
	# cas2 doesn't do byte operands:
	buffers=x
	if test $name = cas2_; then
	    if test $size = 8; then continue; fi
	    buffers="x y"
	fi

	if $header; then
	    echo "TME_M68K_INSN_DECL(tme_m68k_${name}${size});"
	else
	    echo ""
	    echo "/* ${name}${size}: */"
	    echo "TME_M68K_INSN(tme_m68k_${name}${size})"
	    echo "{"
	    echo "  struct tme_m68k_tlb *tlb;"
	    echo "  int ireg_dc, ireg_du;"
	    echo "  int do_write;"
	    echo "  tme_uint16_t specopx = ic->_tme_m68k_insn_specop;"
	    if test $name = cas2_; then
		echo "  tme_uint16_t specopy = ic->_tme_m68k_insn_specop2;"
		echo "  tme_uint32_t addrx;"
		echo "  tme_uint32_t addry;"
		echo ""
		echo "  /* get the function code and addresses we'll be dealing with: */"
		echo "  ic->_tme_m68k_ea_function_code = TME_M68K_FUNCTION_CODE_DATA(ic);"
		echo "  addrx = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_D0"
		echo "                                   + TME_FIELD_EXTRACTU(specopx, 12, 4));"
		echo "  addry = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_D0"
		echo "                                   + TME_FIELD_EXTRACTU(specopy, 12, 4));"
	    fi
	    echo ""
	    echo "  /* start the read/modify/write cycle: */"
	    echo "  tlb = tme_m68k_rmw_start(ic);"
	    echo "  if (tlb == NULL) {"
	    echo "    TME_M68K_INSN_OK;"
	    echo "  }"
	    echo ""
	    echo "  /* read: */"
	    for buffer in $buffers; do
		if test $name = cas2_; then
		    echo "  ic->_tme_m68k_ea_address = addr${buffer};"
		fi
		echo "  tme_m68k_read${size}(ic, tlb,"
		echo "                  &ic->_tme_m68k_ea_function_code,"
		echo "                  &ic->_tme_m68k_ea_address,"
		echo "                  &ic->tme_m68k_ireg_mem${buffer}${size},"
		echo "                  TME_M68K_BUS_CYCLE_RMW);"
	    done

	    echo ""
	    echo "  /* modify: */"
	    for buffer in $buffers; do
		i=
		if test $buffer = y; then
		    echo "  if (ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_Z) {"
		    i="  "
		fi
		echo "${i}  ireg_dc = TME_M68K_IREG_D0 + TME_FIELD_EXTRACTU(specop${buffer}, 0, 3);"
		echo "${i}  tme_m68k_cmp${size}(ic, &ic->tme_m68k_ireg_uint${size}(ireg_dc), &ic->tme_m68k_ireg_mem${buffer}${size});"
		if test $buffer = y; then
		    echo "  }"
		fi
	    done

	    echo ""
	    echo "  /* write: */"
	    echo "  if (ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_Z) {"
	    for buffer in $buffers; do
		if test $name = cas2_; then
		    echo "    ic->_tme_m68k_ea_address = addr${buffer};"
		fi
		echo "    ireg_du = TME_M68K_IREG_D0 + TME_FIELD_EXTRACTU(specop${buffer}, 6, 3);"
		echo "    ic->tme_m68k_ireg_mem${buffer}${size} = ic->tme_m68k_ireg_uint${size}(ireg_du);"
		echo "    tme_m68k_write${size}(ic, tlb,"
		echo "                     &ic->_tme_m68k_ea_function_code,"
		echo "                     &ic->_tme_m68k_ea_address,"
		echo "                     &ic->tme_m68k_ireg_mem${buffer}${size},"
		echo "                     TME_M68K_BUS_CYCLE_RMW);"
	    done
	    echo "  }"
	    echo "  else {"
	    echo "    /* XXX the 68040 always does a write to finish its cycle: */"
	    echo "    do_write = FALSE;"
	    for buffer in $buffers; do
		echo "    ireg_dc = TME_M68K_IREG_D0 + TME_FIELD_EXTRACTU(specop${buffer}, 0, 3);"
		echo -n "    if (do_write"
		if test $name = cas2_; then
		    echo ""
		    echo "        && ic->tme_m68k_ireg_mem${buffer}${size} != ic->tme_m68k_ireg_uint${size}(ireg_dc)) {"
		    echo "      ic->_tme_m68k_ea_address = addr${buffer};"
		else 
		    echo ") {"
		fi
		echo "      tme_m68k_write${size}(ic, tlb,"
		echo "                       &ic->_tme_m68k_ea_function_code,"
		echo "                       &ic->_tme_m68k_ea_address,"
		echo "                       &ic->tme_m68k_ireg_mem${buffer}${size},"
		echo "                       TME_M68K_BUS_CYCLE_RMW);"
		echo "      do_write = FALSE;"
		echo "    }"
		echo "    ic->tme_m68k_ireg_uint${size}(ireg_dc) = ic->tme_m68k_ireg_mem${buffer}${size};"
	    done
	    echo "  }"
	    echo ""
	    echo "  /* finish the read/modify/write cycle: */"
	    echo "  tme_m68k_rmw_finish(ic, tlb);"
	    echo ""
	    echo "  TME_M68K_INSN_OK;"
	    echo "}"
	fi
    done

    # moves:
    if $header; then
	echo "TME_M68K_INSN_DECL(tme_m68k_moves${size});"
    else
	echo ""
	echo "/* moves${size}: */"
	echo "TME_M68K_INSN(tme_m68k_moves${size})"
	echo "{"
	echo "  int ireg;"
	echo "  ireg = TME_M68K_IREG_D0 + TME_FIELD_EXTRACTU(TME_M68K_INSN_SPECOP, 12, 4);"
	echo "  if (TME_M68K_INSN_SPECOP & TME_BIT(11)) {"
	echo "    ic->tme_m68k_ireg_memx${size} = ic->tme_m68k_ireg_uint${size}(ireg${reg_size_shift});"
	echo "  }"
	echo "  else {"
	if test ${size} != 32; then
	    echo "    if (ireg >= TME_M68K_IREG_A0) {"
	    echo "      ic->tme_m68k_ireg_uint32(ireg) = "
	    echo "        TME_EXT_S${size}_U32((tme_int${size}_t) ic->tme_m68k_ireg_memx${size});"
	    echo "    }"
	    echo "    else"
	    echo -n "  "
	fi
	echo "    ic->tme_m68k_ireg_uint${size}(ireg${reg_size_shift}) = ic->tme_m68k_ireg_memx${size};"
	echo "  }"
	echo "  TME_M68K_INSN_OK;"
	echo "}"
    fi
done

# generate the memory read and write functions:

# permute on size:
for size in 8 16 32 any; do

    # permute on read or write:
    for name in read write; do
	capname=`echo $name | tr a-z A-Z`
	if test $name = read; then 
	    lockname="rd"
	    from="from"
	else
	    lockname="wr"
	    from="to"
	fi

	# permute on the special-purpose what:
	for what in memx mem inst stack; do

	    # placeholder for another permutation:
	    :

		# dispatch on the size:
		_first=_first ; _last=_last
		case "$size" in
		8) _first= ; _last= ;;
		esac

		# set up the details of each special purpose:
		rval="void"
		args=""
		args_proto=""
		fc=""
		addr=""
		count=""
		tlb="TME_M68K_TLB_ENTRY(ic, function_code, linear_address${_first})"
		flags="TME_M68K_BUS_CYCLE_NORMAL"
		case "${name}-${what}-${size}" in
		*-memx-8 | *-memx-16 | *-memx-32)
		    action="${name}_${what}${size}"
		    fcptr="&ic->_tme_m68k_ea_function_code"
		    addrptr="&ic->_tme_m68k_ea_address"
		    reg="ic->tme_m68k_ireg_memx${size}"
		    regptr="&${reg}"
		    ;;
		*-mem-any)
		    action="${name}_${what}"
		    args_proto=", tme_uint8_t *, unsigned int"
		    args=", tme_uint8_t *buffer, unsigned int count"
		    fcptr="&ic->_tme_m68k_ea_function_code"
		    addrptr="&ic->_tme_m68k_ea_address"
		    reg=
		    regptr="buffer"
		    ;;
		*-mem-8 | *-mem-16 | *-mem-32)
		    action="${name}_${what}${size}"
		    args_proto=", int"
		    args="${args_proto} ireg"
		    fcptr="&ic->_tme_m68k_ea_function_code"
		    addrptr="&ic->_tme_m68k_ea_address"
		    reg="ic->tme_m68k_ireg_uint${size}(ireg)"
		    regptr="&${reg}"
		    ;;
		read-stack-16 | read-stack-32)
		    action="pop${size}"
		    args_proto=", tme_uint${size}_t *"
		    args="${args_proto}_value"
		    fc="TME_M68K_FUNCTION_CODE_DATA(ic)"
		    addrptr="&ic->tme_m68k_ireg_a7"
		    regptr="_value"
		    reg="*${regptr}"
		    ;;
		write-stack-16 | write-stack-32)
		    action="push${size}"
		    args_proto=", tme_uint${size}_t "
		    args="${args_proto}value"
		    fc="TME_M68K_FUNCTION_CODE_DATA(ic)"
		    addr="ic->tme_m68k_ireg_a7 - sizeof(tme_uint${size}_t)"
		    reg="value"
		    regptr="&${reg}"
		    ;;
		read-inst-16 | read-inst-32)
		    rval="tme_uint${size}_t"
		    action="fetch${size}"
		    args_proto=", tme_uint32_t"
		    args="${args_proto} pc"
		    fc="TME_M68K_FUNCTION_CODE_PROGRAM(ic)"
		    addrptr="&pc"
		    tlb="TME_ATOMIC_READ(struct tme_m68k_tlb *, ic->_tme_m68k_itlb)";
		    flags="TME_M68K_BUS_CYCLE_FETCH"
		    ;;
		*)
		    continue
		    ;;
		esac

		# if we're making the header, just emit a declaration:
		if $header; then
		    echo "${rval} tme_m68k_${action} _TME_P((struct tme_m68k *${args_proto}));"
		    continue
		fi

		# start the function:
		echo ""
		echo "/* this ${name}s a ${size}-bit ${what} value: */"
		echo "${rval}"
		echo "tme_m68k_${action}(struct tme_m68k *ic${args}) "
		echo "{"

		# our locals:
		echo -n "  unsigned int function_code = "
		if test "x${fc}" != x; then
		    echo "${fc};"
		    fc="function_code"
		    fcptr="&function_code"
		else
		    fc=`echo ${fcptr} | sed -e 's,^&,,'`
		    echo "${fc};"
		fi
		echo -n "  tme_uint32_t linear_address${_first} = "
		if test "x${addr}" != x; then
		    echo "${addr};"
		    addr="linear_address${_first}"
		    addrptr="&linear_address${_first}"
		else
		    addr=`echo ${addrptr} | sed -e 's,^&,,'`
		    echo "${addr};"
		fi
		if test "x${count}" = x; then
		    if test $size = any; then count=count; else count="sizeof(tme_uint${size}_t)"; fi
		fi
		if test x$_last != x; then
		    echo "  tme_uint32_t linear_address${_last} = linear_address_first + ${count} - 1;";
		fi
		echo "  struct tme_m68k_tlb *tlb = ${tlb};"
		case "$what" in
		inst)
		    echo "  unsigned int insn_buffer_off = TME_ALIGN(ic->_tme_m68k_insn_buffer_off, sizeof(tme_uint${size}_t));"
		    regptr="((tme_uint${size}_t *) &ic->_tme_m68k_insn_buffer[insn_buffer_off])"
		    reg="*${regptr}"
		    ;;
		esac

		# if this is a write, log the value written:
		if test $name = write; then
		    echo ""
		    echo "  /* log the value written: */"
		    if test $size != any; then
			echo "  tme_m68k_verify_mem${size}(ic, ${fc}, ${addr}, ${reg}, TME_BUS_CYCLE_WRITE);"
			echo "  tme_m68k_log(ic, 1000, TME_OK, "
			echo "               (TME_M68K_LOG_HANDLE(ic),"
			echo "                _(\"${action}\t%d:0x%08x:\t0x%0"`expr ${size} / 4`"x\"),"
			echo "                ${fc},"
			echo "                ${addr},"
			echo "                ${reg}));"
		    else
			echo "  tme_m68k_verify_mem_any(ic, ${fc}, ${addr}, ${regptr}, ${count}, TME_BUS_CYCLE_WRITE);"
			echo "  tme_m68k_log_start(ic, 1000, TME_OK) {"
			echo "    unsigned int byte_i;"
			echo "    tme_log_part(TME_M68K_LOG_HANDLE(ic),"
			echo "                 _(\"${action} %d:0x%08x count %d:\"),"
			echo "                 ${fc},"
			echo "                 ${addr},"
			echo "                 ${count});"
			echo "    for (byte_i = 0; byte_i < count ; byte_i++) {"
			echo "      tme_log_part(TME_M68K_LOG_HANDLE(ic), \" 0x%02x\", (${regptr})[byte_i]);"
			echo "    }"
			echo "  } tme_m68k_log_finish(ic);"
		    fi
		fi

		echo ""
		echo "  /* do the bus cycle(s) ourselves from emulator memory if we can."
		echo "     the emulator memory allocator and TLB filler must guarantee"
		echo "     that all tme_m68k_tlb_emulator_off_${name} pointers be 32-bit"
		echo "     aligned, so that a 16-bit-aligned linear address gets a"
		echo "     16-bit-aligned emulator address: */"
		echo "  if (__tme_predict_true(!TME_M68K_SEQUENCE_RESTARTING"
		if test $size != 8; then
		    echo "                         && !(linear_address${_first} & 1)"
		fi
		echo "                         && TME_M68K_TLB_OK_FAST_${capname}(tlb,"
		echo "                                                      function_code,"
		echo "                                                      linear_address${_first},"
		echo "                                                      linear_address${_last}))) {"

		memptr="(tlb->tme_m68k_tlb_emulator_off_${name} + linear_address${_first})"
		mem="*((tme_uint${size}_t *) ${memptr})"
		if test $name = read; then
		    simple="${reg} = tme_betoh_u${size}(${mem});"
		else
		    simple="${mem} = tme_htobe_u${size}(${reg});"
		fi

		echo ""
		
		# if this is an 8-bit transfer:
		if test $size = 8; then
		    echo "    /* for an 8-bit transfer we can always do a simple "
		    echo "       assignment.  the ${lockname}lock is unnecessary, since we assume"
		    echo "       that 8-bit accesses are always atomic: */"
		    if test $name = read; then
			echo "    ${reg} = ${mem};"
		    else
			echo "    ${mem} = ${reg};"
		    fi
		
		# if this is a 16-bit transfer:
		elif test $size = 16; then
		    echo "    /* for a 16-bit transfer we can always do a simple"
		    echo "       assignment - we tested that the linear address"
		    echo "       is 16-bit aligned, which, since the TLB emulator"
		    echo "       offset is guaranteed to be 32-bit aligned, guarantees"
		    echo "       that the final emulator address is 16-bit aligned."
		    echo ""
		    echo "       we need the ${lockname}lock if we're on an architecture"
		    echo "       where an aligned access may not be atomic: */"
		    echo "    tme_memory_aligned_${lockname}lock(tlb->tme_m68k_tlb_bus_rwlock);"
		    echo "    ${simple}"
		    echo "    tme_memory_aligned_unlock(tlb->tme_m68k_tlb_bus_rwlock);"
		    
		# if this is a 32-bit transfer:
		elif test $size = 32; then

		    echo "    /* if the emulator host allows ${size}-bit quantities to be"
		    echo "       transferred ${from} 16-bit aligned addresses, or if this"
		    echo "       address is ${size}-bit aligned, do the transfer as a simple"
		    echo "       assignment, otherwise transfer two 16-bit words."
		    echo ""
		    echo "       we need the ${lockname}lock if we're on an architecture where"
		    echo "       an aligned access may not be atomic, or if we're doing"
		    echo "       an unaligned access on an architecture where they may"
		    echo "       not be atomic: */"
		    misaligned="(linear_address${_first} & (sizeof(tme_uint${size}_t) - 1))"
		    echo "#if ALIGNOF_INT${size}_T <= ALIGNOF_INT16_T"
		    echo "#ifdef TME_UNALIGNED_ACCESS_ATOMIC"
		    echo "    ${simple}"
		    echo "#else  /* !TME_UNALIGNED_ACCESS_ATOMIC */"
		    echo "    if (${misaligned}) {"
		    echo "      tme_memory_unaligned_${lockname}lock(tlb->tme_m68k_tlb_bus_rwlock);"
		    echo "      ${simple}"
		    echo "      tme_memory_unaligned_unlock(tlb->tme_m68k_tlb_bus_rwlock);"
		    echo "    }"
		    echo "    else {"
		    echo "      tme_memory_aligned_${lockname}lock(tlb->tme_m68k_tlb_bus_rwlock);"
		    echo "      ${simple}"
		    echo "      tme_memory_aligned_unlock(tlb->tme_m68k_tlb_bus_rwlock);"
		    echo "    }"
		    echo "#endif /* !TME_UNALIGNED_ACCESS_ATOMIC */"
		    echo "#else  /* ALIGNOF_INT${size}_T > ALIGNOF_INT16_T */"
		    echo "    if (TME_SEQUENCE_ACCESS_NOT_COSTLIER || ${misaligned}) {"
		    echo "      tme_memory_sequence_${lockname}lock(tlb->tme_m68k_tlb_bus_rwlock); "
		    if test $name = read; then
			echo "#ifdef WORDS_BIGENDIAN"
			echo "      ${reg} = (((tme_uint${size}_t) ((tme_uint16_t *) ${memptr})[0]) << 16) | ((tme_uint16_t *) ${memptr})[1];"
			echo "#else  /* !WORDS_BIGENDIAN */"
			echo "      ${reg} = tme_betoh_u32((((tme_uint${size}_t) ((tme_uint16_t *) ${memptr})[1]) << 16) | ((tme_uint16_t *) ${memptr})[0]);"
			echo "#endif /* !WORDS_BIGENDIAN */"
		    else
			echo "      ((tme_uint16_t *) ${memptr})[0] = tme_htobe_u16(${reg} >> 16);"
			echo "      ((tme_uint16_t *) ${memptr})[1] = tme_htobe_u16(${reg} & 0xffff);"
		    fi
		    echo "      tme_memory_sequence_unlock(tlb->tme_m68k_tlb_bus_rwlock); "
		    echo "    }"
		    echo "    else {"
		    echo "      tme_memory_aligned_${lockname}lock(tlb->tme_m68k_tlb_bus_rwlock); "
		    echo "      ${simple}"
		    echo "      tme_memory_aligned_unlock(tlb->tme_m68k_tlb_bus_rwlock); "
		    echo "    }"
		    echo "#endif /* ALIGNOF_INT${size}_T != 1 */"
		    
		# if this is an any-transfer:
		elif test $size = any; then
		    echo "    tme_memory_sequence_${lockname}lock(tlb->tme_m68k_tlb_bus_rwlock);"
		    if test $name = read; then
			echo "    memcpy(${regptr}, ${memptr}, ${count});"
		    else
			echo "    memcpy(${memptr}, ${regptr}, ${count});"
		    fi
		    echo "    tme_memory_sequence_unlock(tlb->tme_m68k_tlb_bus_rwlock);"

		fi
		echo "    TME_M68K_SEQUENCE_TRANSFER_STEP;"
		echo "  }"

		echo ""
		echo "  /* otherwise, do the bus cycles the slow way: */"
		echo "  else {"
		if test $size != any; then
		    echo "    tme_m68k_${name}${size}(ic, tlb,"
		    echo "                    ${fcptr},"
		    echo "                    ${addrptr},"
		    echo "                    ${regptr},"
		    echo "                    ${flags});"
		else
		    echo "    tme_m68k_${name}(ic, tlb, ${fcptr}, ${addrptr}, ${regptr}, ${count}, TME_M68K_BUS_CYCLE_RAW);"
		fi
		echo "  }"
		
		# if this is a read, log the value read:
		if test $name = read; then
		    echo ""
		    echo "  /* log the value read: */"
		    if test $size != any; then
			echo "  tme_m68k_verify_mem${size}(ic, ${fc}, ${addr}, ${reg}, TME_BUS_CYCLE_READ);"
			echo "  tme_m68k_log(ic, 1000, TME_OK,"
			echo "               (TME_M68K_LOG_HANDLE(ic),"
			echo "                _(\"${action}\t%d:0x%08x:\t0x%0"`expr ${size} / 4`"x\"),"
			echo "                ${fc},"
			echo "                ${addr},"
			echo "                ${reg}));"
		    else
			echo "  tme_m68k_verify_mem_any(ic, ${fc}, ${addr}, ${regptr}, ${count}, TME_BUS_CYCLE_READ);"
			echo "  tme_m68k_log_start(ic, 1000, TME_OK) {"
			echo "    unsigned int byte_i;"
			echo "    tme_log_part(TME_M68K_LOG_HANDLE(ic),"
			echo "                 _(\"${action} %d:0x%08x count %d:\"),"
			echo "                 ${fc},"
			echo "                 ${addr},"
			echo "                 ${count});"
			echo "    for (byte_i = 0; byte_i < count ; byte_i++) {"
			echo "      tme_log_part(TME_M68K_LOG_HANDLE(ic), \" 0x%02x\", (${regptr})[byte_i]);"
			echo "    }"
			echo "  } tme_m68k_log_finish(ic);"
		    fi
		fi

		# perform any updating and value returning:
		case "$what" in
		stack)
		    if test $name = read; then dir="+"; else dir="-"; fi
		    echo "  if (!TME_M68K_SEQUENCE_RESTARTING) {"
		    echo "    ic->tme_m68k_ireg_a7 ${dir}= sizeof(tme_uint${size}_t);"
		    echo "  }"
		    ;;
		inst)
		    echo "  ic->_tme_m68k_insn_buffer_off = insn_buffer_off + sizeof(tme_uint${size}_t);"
		    echo "  return(${reg});"
		    ;;
		esac

		echo "}"
	    :
	done

	# the general-purpose cycle-making read and write macros:
	if test ${size} != any; then

	    # if we're making the header, emit a macro:
	    if $header; then
		echo "#define tme_m68k_${name}${size}(ic, t, fc, la, _v, f) \\"
		echo "  tme_m68k_${name}(ic, t, fc, la, (tme_uint8_t *) (_v), sizeof(tme_uint${size}_t), f)"
	    fi
	else

	    # if we're making the header, just emit a declaration:
	    if $header; then
		echo "void tme_m68k_${name} _TME_P((struct tme_m68k *, struct tme_m68k_tlb *, unsigned int *, tme_uint32_t *, tme_uint8_t *, unsigned int, unsigned int));"
		continue
	    fi

	    echo ""
	    echo "/* this ${name}s a region of address space using actual bus cycles: */"
	    echo "void"
	    echo "tme_m68k_${name}(struct tme_m68k *ic, "
	    echo "              struct tme_m68k_tlb *tlb,"
	    echo "              unsigned int *_function_code, "
	    echo "              tme_uint32_t *_linear_address, "
	    echo "              tme_uint8_t *reg,"
	    echo "              unsigned int reg_size,"
	    echo "              unsigned int flags)"
	    echo "{"

	    # our locals:
	    echo "  unsigned int function_code;"
	    echo "  tme_uint32_t linear_address;"
	    echo "  tme_bus_addr_t physical_address;"
	    echo "  int shift;"
	    echo "  struct tme_bus_cycle cycle;"
	    echo "  unsigned int transferred, resid, cycle_size;"
	    echo "  int exception;"
	    echo "  tme_rwlock_t *rmw_rwlock;"
	    echo "  int err;"
	    echo "#ifndef WORDS_BIGENDIAN"
	    echo "  tme_uint8_t *reg_p;"
	    echo "  unsigned int buffer_i;"
	    echo "#endif /* !WORDS_BIGENDIAN */"

	    echo ""
	    echo "  /* if we're not restarting, everything is fresh: */"
	    echo "  if (!TME_M68K_SEQUENCE_RESTARTING) {"
	    echo "    function_code = *_function_code;"
	    echo "    linear_address = *_linear_address;"
	    echo "    transferred = 0;"
	    echo "  }"

	    echo ""
	    echo "  /* otherwise, if this is the transfer that faulted, restore"
	    echo "     our state to the cycle that faulted, then take into account"
	    echo "     any data provided by a software rerun of the faulted cycle: */"
	    echo "  else if (ic->_tme_m68k_sequence._tme_m68k_sequence_transfer_faulted"
	    echo "           == ic->_tme_m68k_sequence._tme_m68k_sequence_transfer_next) {"
	    echo "    function_code = *_function_code = ic->_tme_m68k_group0_function_code;"
	    echo "    linear_address = ic->_tme_m68k_group0_address;"
	    echo "    transferred = ic->_tme_m68k_sequence._tme_m68k_sequence_transfer_faulted_after;"
	    echo "    if (transferred >= reg_size) abort();"
	    echo "    *_linear_address = linear_address - transferred;"
	    echo "    resid = reg_size - transferred;"
	    echo "    if (ic->_tme_m68k_group0_buffer_${name}_size > resid) abort();"
	    echo "    if (ic->_tme_m68k_group0_buffer_${name}_softrr > resid) abort();"
	    if test $name = read; then cmp=">"; else cmp="=="; fi
	    echo "    if (ic->_tme_m68k_group0_buffer_${name}_softrr ${cmp} 0) {"
	    echo "#ifdef WORDS_BIGENDIAN"
	    echo "      memcpy(reg + transferred, "
	    echo "             ic->_tme_m68k_group0_buffer_${name},"
	    echo "             ic->_tme_m68k_group0_buffer_${name}_size);"
	    echo "#else  /* !WORDS_BIGENDIAN */"
	    echo "      reg_p = (reg + reg_size - 1) - transferred;"
	    echo "      for (buffer_i = 0;"
	    echo "           buffer_i < ic->_tme_m68k_group0_buffer_${name}_size;"
	    echo "           buffer_i++) {"
	    echo "        *(reg_p--) = ic->_tme_m68k_group0_buffer_${name}[buffer_i];"
	    echo "      }"
	    echo "#endif /* !WORDS_BIGENDIAN */"
	    echo "    }"
	    echo "    transferred += ic->_tme_m68k_group0_buffer_${name}_softrr;"
	    echo "  }"

	    echo ""
	    echo "  /* otherwise, a later transfer has faulted.  just step the"
	    echo "     transfer number and return: */"
	    echo "  else {"
	    echo "    TME_M68K_SEQUENCE_TRANSFER_STEP;"
	    echo "    return;"
	    echo "  }"

	    echo ""
	    echo "  /* do as many bus cycles as needed to complete the transfer: */"
	    echo "  rmw_rwlock = tlb->tme_m68k_tlb_bus_rwlock;"
	    echo "  exception = TME_M68K_EXCEPTION_NONE;"
	    echo "  cycle_size = 0;"
	    echo "  for(; transferred < reg_size; ) {"
	    echo "    resid = reg_size - transferred;"

	    echo ""
	    echo "    /* start the bus cycle structure: */"
	    echo "    cycle.tme_bus_cycle_type = TME_BUS_CYCLE_${capname};"
	    echo "    if (TME_ENDIAN_NATIVE == TME_ENDIAN_BIG"
	    echo "        || (flags & TME_M68K_BUS_CYCLE_RAW)) {"
	    echo "      cycle.tme_bus_cycle_buffer = reg + transferred;"
	    echo "      cycle.tme_bus_cycle_buffer_increment = 1;"
	    echo "    }"
	    echo "    else {"
	    echo "      cycle.tme_bus_cycle_buffer = reg + reg_size - (1 + transferred);"
	    echo "      cycle.tme_bus_cycle_buffer_increment = -1;"
	    echo "    }"

	    echo ""
	    echo "    /* if we're emulating a CPU with a 16-bit bus interface: */"
	    echo "    if (ic->_tme_m68k_bus_16bit) {"
	    echo ""
	    echo "      /* if we're trying to transfer a non-power-of-two"
	    echo "         number of bytes, either the CPU is broken (no"
	    echo "         instructions ever transfer a non-power-of-two"
	    echo "         number of bytes), or this function allowed an"
	    echo "         unaligned transfer: */"
	    echo "      assert((resid & (resid - 1)) == 0"
	    echo "             || (flags & TME_M68K_BUS_CYCLE_RAW));"
	    echo ""
	    echo "      /* only byte transfers can be unaligned: */"
	    echo "      if (resid > sizeof(tme_uint8_t)"
	    echo "          && (linear_address & 1)) {"
	    echo "          exception = TME_M68K_EXCEPTION_GROUP0_AERR;"
	    echo "          break;"
	    echo "      }"
	    echo ""
	    echo "      /* set the bus-size specific parts of the bus cycle structure: */"
	    echo "      cycle_size = TME_MIN(resid, sizeof(tme_uint16_t));"
	    echo "      cycle.tme_bus_cycle_size = cycle_size;"
	    echo "      cycle.tme_bus_cycle_port = TME_BUS_CYCLE_PORT(0, TME_BUS16_LOG2);"
	    echo "      cycle.tme_bus_cycle_lane_routing = "
	    echo "        &tme_m68k_router_16[TME_M68K_BUS_ROUTER_INDEX(TME_BUS16_LOG2, cycle_size, linear_address)];"
	    echo "    }"
	    echo ""
	    echo "    /* otherwise we're emulating a CPU with a 32-bit bus interface: */"
	    echo "    else {"
	    if test $name = read; then
		echo ""
		echo "      /* an instruction fetch must be aligned: */"
		echo "      if (flags & TME_M68K_BUS_CYCLE_FETCH) {"
		echo "        if (linear_address & 1) {"
		echo "          exception = TME_M68K_EXCEPTION_GROUP0_AERR;"
		echo "          break;"
		echo "        }"
		echo "        assert(!(resid & 1));"
		echo "      }"
	    fi
	    echo ""
	    echo "      /* set the bus-size specific parts of the bus cycle structure: */"
	    echo "      cycle_size = TME_MIN(resid, sizeof(tme_uint32_t) - (linear_address & (sizeof(tme_uint32_t) - 1)));"
	    echo "      cycle.tme_bus_cycle_size = cycle_size;"
	    echo "      cycle.tme_bus_cycle_port = TME_BUS_CYCLE_PORT(0, TME_BUS32_LOG2);"
	    echo "      cycle.tme_bus_cycle_lane_routing = "
	    echo "        &tme_m68k_router_32[TME_M68K_BUS_ROUTER_INDEX(TME_BUS32_LOG2, cycle_size, linear_address)];"
	    echo "    }"
	
	    echo ""
	    echo "    /* reload the TLB entry: */"
	    echo "    if (!TME_M68K_TLB_OK_SLOW_${capname}(tlb, function_code, linear_address)) {"
	    echo "      tme_m68k_tlb_fill(ic, tlb,"
	    echo "                        function_code,"
	    echo "                        linear_address,"
	    echo "                        TME_BUS_CYCLE_${capname});"
	    echo "    }"
	    echo ""
	    echo "    /* if this is a part of a read/modify/write cycle: */"
	    echo "    if (flags & TME_M68K_BUS_CYCLE_RMW) {"
	    echo ""
	    echo "      /* if this TLB entry doesn't support fast ${name}s, or"
	    echo "         if the TLB lock has changed, that's a bus error."
	    echo "         see the discussion in tme_m68k_rmw_start: */"
	    echo "      if (!TME_M68K_TLB_OK_FAST_${capname}(tlb, function_code, linear_address, linear_address)"
	    echo "          || (rmw_rwlock != NULL"
	    echo "              && rmw_rwlock != tlb->tme_m68k_tlb_bus_rwlock)) {"
	    echo "        exception = TME_M68K_EXCEPTION_GROUP0_BERR;"
	    echo "        break;"
	    echo "      }"
	    echo ""
	    echo "      /* if we haven't locked this memory yet, do so: */"
	    echo "      if (rmw_rwlock == NULL) {"
	    echo "        rmw_rwlock = tlb->tme_m68k_tlb_bus_rwlock;"
	    echo "        tme_rwlock_wrlock(rmw_rwlock);"
	    echo "      }"
	    echo "    }"

	    echo ""
	    echo "    /* form the physical address for the bus cycle handler: */"
	    echo "    physical_address = tlb->tme_m68k_tlb_addr_offset + linear_address;"
	    echo "    shift = tlb->tme_m68k_tlb_addr_shift;"
	    echo "    if (shift < 0) {"
	    echo "      physical_address <<= (0 - shift);"
	    echo "    }"
	    echo "    else if (shift > 0) {"
	    echo "      physical_address >>= shift;"
	    echo "    }"
	    echo "    cycle.tme_bus_cycle_address = physical_address;"

	    echo ""
	    echo "    /* run the bus cycle: */"
	    echo "    err = (*tlb->tme_m68k_tlb_bus_tlb.tme_bus_tlb_cycle)"
	    echo "         (tlb->tme_m68k_tlb_bus_tlb.tme_bus_tlb_cycle_private, &cycle);"
	    echo ""
	    echo "    /* if we deadlocked, we have no locks to release"
	    echo "       ourselves, so sleep a while waiting for things"
	    echo "       to clear up, then try again: */"
	    echo "    if (err == TME_EDEADLK) {"
	    echo "      TME_THREAD_DEADLOCK_SLEEP();"
	    echo "      cycle.tme_bus_cycle_address = physical_address;"
	    echo "    }"
	    echo ""
	    echo "    /* otherwise, any other error might be a bus error: */"
	    echo "    else if (err != TME_OK) {"
	    echo "      err = tme_bus_tlb_fault(&tlb->tme_m68k_tlb_bus_tlb, &cycle, err);"
	    echo "      if (err != TME_OK) {"
	    echo "        exception = TME_M68K_EXCEPTION_GROUP0_BERR;"
	    echo "        break;"
	    echo "      }"
	    echo "    }"
	    echo ""
	    echo "    /* update: */"
	    echo "    linear_address += cycle.tme_bus_cycle_size;"
	    echo "    transferred += cycle.tme_bus_cycle_size;"
	    echo "  }"
       
	    echo ""
	    echo "  /* if we got an exception and there is a locked"
	    echo "     read/modify/write rwlock, unlock it: */"
	    echo "  if (exception != TME_M68K_EXCEPTION_NONE"
	    echo "      && (flags & TME_M68K_BUS_CYCLE_RMW)"
	    echo "      && rmw_rwlock != NULL) {"
	    echo "    tme_rwlock_unlock(rmw_rwlock);"
	    echo "  }"

	    echo ""
	    echo "  /* if we faulted, stash the information the fault stacker"
	    echo "     will need and start exception processing: */"
	    echo "  if (exception != TME_M68K_EXCEPTION_NONE) {"
	    echo -n "    ic->_tme_m68k_group0_flags = flags"
	    if test $name = read; then
		echo -n " | TME_M68K_BUS_CYCLE_READ"
	    fi
	    echo ";"
	    echo "    ic->_tme_m68k_group0_function_code = function_code;"
	    echo "    ic->_tme_m68k_group0_address = linear_address;"
	    echo "    ic->_tme_m68k_group0_sequence = ic->_tme_m68k_sequence;"
	    echo "    ic->_tme_m68k_group0_sequence._tme_m68k_sequence_transfer_faulted_after = transferred;"
	    echo "    ic->_tme_m68k_group0_buffer_${name}_size = cycle_size;"
	    if test $name = write; then
		echo "#ifdef WORDS_BIGENDIAN"
		echo "    memcpy(ic->_tme_m68k_group0_buffer_${name},"
		echo "           reg + transferred,"
		echo "           ic->_tme_m68k_group0_buffer_${name}_size);"
		echo "#else  /* !WORDS_BIGENDIAN */"
		echo "      reg_p = (reg + reg_size - 1) - transferred;"
		echo "      for (buffer_i = 0;"
		echo "           buffer_i < ic->_tme_m68k_group0_buffer_${name}_size;"
		echo "           buffer_i++) {"
		echo "        ic->_tme_m68k_group0_buffer_${name}[buffer_i] = *(reg_p--);"
		echo "      }"
		echo "#endif /* !WORDS_BIGENDIAN */"
	    fi
	    echo "    if (ic->_tme_m68k_group0_hook != NULL) {"
	    echo "      (*ic->_tme_m68k_group0_hook)(ic);"
	    echo "    }"
	    echo "    ic->_tme_m68k_group0_sequence._tme_m68k_sequence_transfer_faulted = ";
	    echo "      ic->_tme_m68k_group0_sequence._tme_m68k_sequence_transfer_next;"
	    echo "    tme_m68k_exception(ic, exception);"
	    echo "  }"

	    echo ""
	    echo "  /* otherwise, this transfer has now completed: */"
	    echo "  TME_M68K_SEQUENCE_TRANSFER_STEP;"

	    echo "}"
	fi
    done

done

# generate the BCD math functions:
for name in abcd sbcd nbcd; do

    # if we're making the header, just emit a declaration:
    if $header; then
	echo "TME_M68K_INSN_DECL(tme_m68k_${name});"
	continue
    fi

    # emit the function:
    echo ""
    echo "TME_M68K_INSN(tme_m68k_${name})"
    echo "{"
    echo "  tme_uint8_t dst, dst_msd, dst_lsd;"
    echo "  tme_uint8_t src, src_msd, src_lsd;"
    echo "  tme_uint8_t res, res_msd, res_lsd;"
    echo "  tme_uint8_t flags;"

    # get the operands:
    if test $name != nbcd; then
	echo "  int memory;"
	echo "  int rx, ry, function_code;"
	echo ""
	echo "  TME_M68K_INSN_CANFAULT;"
	echo ""
	echo "  /* load the operands: */"
	echo "  rx = TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 0, 3);"
	echo "  ry = TME_FIELD_EXTRACTU(TME_M68K_INSN_OPCODE, 9, 3);"
	echo "  memory = (TME_M68K_INSN_OPCODE & TME_BIT(3)) != 0;"
	echo "  function_code = TME_M68K_FUNCTION_CODE_DATA(ic);"
	echo "  if (memory) {"
	echo "    if (!TME_M68K_SEQUENCE_RESTARTING) {"
	echo "      ic->_tme_m68k_ea_function_code = function_code;"
	echo "      ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + rx);"
	echo "    }"
	echo "    tme_m68k_read_memx8(ic);"
	echo "    if (!TME_M68K_SEQUENCE_RESTARTING) {"
	echo "      ic->_tme_m68k_ea_function_code = function_code;"
	echo "      ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ry);"
	echo "    }"
	echo "    tme_m68k_read_mem8(ic, TME_M68K_IREG_MEMY32);"
	echo "    src = ic->tme_m68k_ireg_memx8;"
	echo "    dst = ic->tme_m68k_ireg_memy8;"
	echo "  }"
	echo "  else {"
	echo "    src = ic->tme_m68k_ireg_uint8(rx << 2);"
	echo "    dst = ic->tme_m68k_ireg_uint8(ry << 2);"
	echo "  }"
    else
	echo ""
	echo "  dst = 0x00;"
	echo "  src = TME_M68K_INSN_OP1(tme_uint8_t);"
    fi
    echo "  dst_lsd = TME_FIELD_EXTRACTU(dst, 0, 4);"
    echo "  dst_msd = TME_FIELD_EXTRACTU(dst, 4, 4);"
    echo "  src_lsd = TME_FIELD_EXTRACTU(src, 0, 4);"
    echo "  src_msd = TME_FIELD_EXTRACTU(src, 4, 4);"

    # perform the operation:
    echo ""
    echo "  /* perform the operation: */"
    if test $name = abcd; then op='+' ; opc='-' ; else op='-' ; opc='+' ; fi
    echo "  res_lsd = dst_lsd ${op} src_lsd ${op} ((ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_X) != 0);"
    echo "  res_msd = dst_msd ${op} src_msd;"
    echo "  flags = 0;"
    echo "  if (res_lsd > 9) {"
    echo "    res_lsd ${opc}= 10;"
    echo "    res_msd ${op}= 1;"
    echo "  }"
    echo "  if (res_msd > 9) {"
    echo "    res_msd ${opc}= 10;"
    echo "    flags |= TME_M68K_FLAG_C | TME_M68K_FLAG_X;"
    echo "  }"
    echo "  res = (res_msd << 4) + (res_lsd & 0xf);"
    echo "  if (res == 0) flags |= TME_M68K_FLAG_N;"
    echo ""

    # store the result
    echo "  /* store the result and set the flags: */"
    if test $name != nbcd; then
	echo "  if (memory) {"
	echo "    if (!TME_M68K_SEQUENCE_RESTARTING) {"
	echo "      ic->tme_m68k_ireg_memx8 = res;"
	echo "      ic->_tme_m68k_ea_function_code = function_code;"
	echo "      ic->_tme_m68k_ea_address = ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ry);"
	# the stack pointer must always be incremented by a multiple of two.
	# assuming rx < 8, ((rx + 1) >> 3) == 1 iff rx == 7, meaning %a7:
	echo "      ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + rx) += sizeof(tme_uint8_t) + ((rx + 1) >> 3);"
	echo "      ic->tme_m68k_ireg_uint32(TME_M68K_IREG_A0 + ry) += sizeof(tme_uint8_t) + ((ry + 1) >> 3);"
	echo "      ic->tme_m68k_ireg_ccr = flags;"
	echo "     }"
	echo "     tme_m68k_write_memx8(ic);"
	echo "  }"
	echo "  else {"
	echo "    ic->tme_m68k_ireg_uint8(ry << 2) = res;"
	echo "    ic->tme_m68k_ireg_ccr = flags;"
	echo "  }"
    else
	echo "  TME_M68K_INSN_OP1(tme_uint8_t) = res;"
	echo "  ic->tme_m68k_ireg_ccr = flags;"
    fi
    echo ""
    echo "  TME_M68K_INSN_OK;"
    echo "}"
done

# generate the ccr and sr functions:
for reg in ccr sr; do
    for name in ori andi eori move_to; do
	if test $reg = ccr; then size=8 ; else size=16 ; fi

	# if we're making the header, just emit a declaration:
	if $header; then
	    echo "TME_M68K_INSN_DECL(tme_m68k_${name}_${reg});"
	    continue
	fi

	# emit the function:
	echo ""
	echo "TME_M68K_INSN(tme_m68k_${name}_${reg})"
	echo "{"
	echo "  tme_uint${size}_t reg;"

	# form the new register value:
	src=0
	echo -n "  reg = "
	case $name in
	ori) echo -n "ic->tme_m68k_ireg_${reg} | " ;;
	andi) echo -n "ic->tme_m68k_ireg_${reg} & " ;;
	eori) echo -n "ic->tme_m68k_ireg_${reg} ^ " ;;
	move_to) size=16 ; src=1 ;;
	esac
	echo "(TME_M68K_INSN_OP${src}(tme_uint${size}_t) & TME_M68K_FLAG_"`echo $reg | tr a-z A-Z`");"
	
	# sr changes are special:
	if test $reg = sr; then
	    echo "  TME_M68K_INSN_PRIV;"
	    echo "  TME_M68K_INSN_CHANGE_SR(reg);"
	else
	    echo "  ic->tme_m68k_ireg_${reg} = reg;"
	fi

	echo "  TME_M68K_INSN_OK;"
	echo "}"
    done
done

# generate the multiply and divide instructions:

# permute on signed vs. unsigned:
for _sign in u s; do
    if test $_sign = u; then sign=u; else sign=; fi

    # permute on short vs. long:
    for size in s l; do
	if test $size = s; then 
	    _size=
	    small=16
	    large=32
	    reg_size_shift=' << 1'
	else
	    _size=l
	    small=32
	    large=64
	    reg_size_shift=
	fi

	# if we're making the header, just emit declarations:
	if $header; then
	    echo "TME_M68K_INSN_DECL(tme_m68k_mul${_sign}${_size});"
	    echo "TME_M68K_INSN_DECL(tme_m68k_div${_sign}${_size});"
	    continue
	fi

	# emit the multiply function:
	echo ""
	echo "TME_M68K_INSN(tme_m68k_mul${_sign}${_size})"
	echo "{"
 	if test $large = 64; then
	    echo "#ifndef HAVE_UINT${large}_T"
	    echo "  abort();"
	    echo "#else /* HAVE_UINT${large}_T */"
	    echo "  unsigned int flag_v;"
	    echo "  int ireg_dh;"
	fi
	echo "  int ireg_dl;"
	echo "  tme_${sign}int${large}_t res;"
	echo "  tme_uint8_t flags;"

	echo ""
	echo "  /* get the register containing the factor: */"
	echo -n "  ireg_dl = TME_M68K_IREG_D0 + "
	if test $size = s; then
	    echo "TME_M68K_INSN_OP0(tme_uint32_t);"
	else
	    echo "TME_FIELD_EXTRACTU(TME_M68K_INSN_SPECOP, 12, 3);"
	fi

	echo ""
	echo "  /* perform the multiplication: */"
	echo "  res = (((tme_${sign}int${large}_t) ic->tme_m68k_ireg_${sign}int${small}(ireg_dl${reg_size_shift}))"
	echo "         * TME_M68K_INSN_OP1(tme_${sign}int${small}_t));"
	
	echo ""
	echo "  /* store the result: */"
	echo "  ic->tme_m68k_ireg_${sign}int32(ireg_dl) = (tme_${sign}int32_t) res;"
	if test $large = 64; then
	    echo "  flag_v = TME_M68K_FLAG_V;"
	    echo "  if (TME_M68K_INSN_SPECOP & TME_BIT(10)) {"
	    echo "    flag_v = 0;"
	    echo "    ireg_dh = TME_M68K_IREG_D0 + TME_FIELD_EXTRACTU(TME_M68K_INSN_SPECOP, 0, 3);"
	    echo "    ic->tme_m68k_ireg_${sign}int32(ireg_dh) = (tme_${sign}int32_t) (res >> 32);"
	    echo "  }"
	fi
	
	echo ""
	echo "  /* set the flags: */"
	echo "  flags = ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_X;"
	echo "  if (((tme_int${large}_t) res) < 0) flags |= TME_M68K_FLAG_N;"
	echo "  if (res == 0) flags |= TME_M68K_FLAG_Z;"
	if test $large = 64; then
	    echo -n "  if (res > 0xffffffff"
	    if test $_sign = s; then echo -n " || res < -2147483648"; fi
	    echo ") flags |= flag_v;"
	fi
	echo "  ic->tme_m68k_ireg_ccr = flags;"

	echo ""
	echo "  TME_M68K_INSN_OK;"
 	if test $large = 64; then
	    echo "#endif /* HAVE_UINT${large}_T */"
	fi
	echo "}"

	# emit the divide function:
	echo ""
	echo "TME_M68K_INSN(tme_m68k_div${_sign}${_size})"
	echo "{"
 	if test $large = 64; then
	    echo "#ifndef HAVE_UINT${large}_T"
	    echo "  abort();"
	    echo "#else /* HAVE_UINT${large}_T */"
	    echo "  int ireg_dr;"
	fi
	echo "  int ireg_dq;"
	echo "  tme_${sign}int${large}_t dividend, quotient;"
	echo "  tme_${sign}int${small}_t divisor, remainder;"
	echo "  tme_uint8_t flags;"

	echo ""
	echo "  /* get the register(s): */"
	echo -n "  ireg_dq = TME_M68K_IREG_D0 + "
	if test $size = s; then
	    echo "TME_M68K_INSN_OP0(tme_uint32_t);"
	else
	    echo "TME_FIELD_EXTRACTU(TME_M68K_INSN_SPECOP, 12, 3);"
	    echo "  ireg_dr = TME_M68K_IREG_D0 + TME_FIELD_EXTRACTU(TME_M68K_INSN_SPECOP, 0, 3);"
	fi

	echo ""
	echo "  /* form the dividend and the divisor: */"
	if test $large = 64; then
	    echo "  if (TME_M68K_INSN_SPECOP & TME_BIT(10)) {"
	    echo "    dividend = (tme_${sign}int${large}_t)"
	    echo "               ((((tme_uint${large}_t) ic->tme_m68k_ireg_uint32(ireg_dr)) << 32)"
	    echo "                | ic->tme_m68k_ireg_uint32(ireg_dq));"
	    echo "  }"
	    echo "  else"
	    echo -n "  "
	fi
	echo "  dividend = (tme_${sign}int${large}_t) ic->tme_m68k_ireg_${sign}int32(ireg_dq);"
	echo "  divisor = TME_M68K_INSN_OP1(tme_${sign}int${small}_t);"
	echo "  if (divisor == 0) {"
	echo "    ic->tme_m68k_ireg_pc = ic->tme_m68k_ireg_pc_next;"
	echo "    TME_M68K_INSN_EXCEPTION(TME_M68K_EXCEPTION_GROUP2(5));"
	echo "  }"

	echo ""
	echo "  /* do the division: */"
	echo "  quotient = dividend / divisor;"
	echo "  remainder = dividend % divisor;"

	echo ""
	echo "  /* set the flags and return the quotient and remainder: */"
	echo "  flags = ic->tme_m68k_ireg_ccr & TME_M68K_FLAG_X;"
	echo -n "  if (quotient > 0xffff"
	if test $small = 16; then
	    if test $_sign = s; then echo -n " || quotient < -32768"; fi
	else
	    echo -n "ffff"
	    if test $_sign = s; then echo -n " || quotient < -2147483648"; fi
	fi
	echo ") {"
	echo "    flags |= TME_M68K_FLAG_V;"
	echo "  }"
	echo "  else {"
	echo "    if (((tme_int${small}_t) quotient) < 0) flags |= TME_M68K_FLAG_N;"
	echo "    if (quotient == 0) flags |= TME_M68K_FLAG_Z;"
	echo "    ic->tme_m68k_ireg_${sign}int${small}(ireg_dq${reg_size_shift}) = (tme_${sign}int${small}_t) quotient;"
	if test $small = 16; then
	    echo "    ic->tme_m68k_ireg_${sign}int${small}((ireg_dq${reg_size_shift}) + 1) = remainder;"
	else
	    echo "    if (ireg_dr != ireg_dq) {"
	    echo "      ic->tme_m68k_ireg_${sign}int${small}(ireg_dr) = remainder;"
	    echo "    }"
	fi
	echo "  }"
	echo "  ic->tme_m68k_ireg_ccr = flags;"

	echo ""
	echo "  TME_M68K_INSN_OK;"
 	if test $large = 64; then
	    echo "#endif /* HAVE_UINT${large}_T */"
	fi
	echo "}"

    done
done

# done:
exit 0
