#! /bin/sh

# $Id: sparc-insns-auto.sh,v 1.5 2007/03/29 01:16:09 fredette Exp $

# ic/sparc/sparc-insns-auto.sh - automatically generates C code 
# for many SPARC emulation instructions:

#
# Copyright (c) 2005 Matt Fredette
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#      This product includes software developed by Matt Fredette.
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

header=false

for option
do
    case $option in
    --header) header=true ;;
    esac
done

PROG=`basename $0`
cat <<EOF
/* automatically generated by $PROG, do not edit! */
_TME_RCSID("\$Id: sparc-insns-auto.sh,v 1.5 2007/03/29 01:16:09 fredette Exp $");

EOF
if $header; then :; else
    cat <<EOF
#include "sparc-impl.h"
EOF
fi

# permute over architecture:
#
for arch in 32; do

    # the sparc64 support depends on a 64-bit integer type:
    #
    if test ${arch} = 64; then
	echo ""
	echo "#ifdef TME_HAVE_INT64_T"
    fi

    # get the name of the register with the integer condition codes, a
    # shift value for 32-bit registers, and the architecture version:
    #
    if test ${arch} = 32; then 
	ccr=32_PSR
	ccr_ireg='tme_sparc32_ireg_psr'
	reg32_shift=''
	version=8
    else
	ccr=64_CCR
	ccr_ireg='tme_sparc64_ireg_ccr'
	reg32_shift=' << 1'
	version=9
    fi

    # fix the architecture version:
    #
    if $header; then :; else
	echo ""
	echo "#undef TME_SPARC_VERSION"
	echo "#define TME_SPARC_VERSION(ic) (${version})"
    fi

    # the alternate ASI function:
    #
    if $header; then :; else
	echo "static tme_uint32_t"
	echo "_tme_sparc${arch}_alternate_asi_mask(struct tme_sparc *ic)"
	echo "{"
	echo "  unsigned int asi_data;"
	echo "  tme_uint32_t asi_mask_data;"
	echo ""
	echo "  /* get the ASI, assuming that the i bit is zero: */"
	echo "  asi_data = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, (0xff << 5));"
	if test ${arch} = 32; then
	    echo ""
	    echo "  /* this is a privileged instruction: */"
	    echo "  TME_SPARC_INSN_PRIV;"
	    echo ""
	    echo "  /* if the i bit is one, this is an illegal instruction: */"
	    echo "  if (__tme_predict_false(TME_SPARC_INSN & TME_BIT(13))) {"
	    echo "    TME_SPARC_INSN_ILL;"
	    echo "  }"
	    echo ""
	    echo "  /* map the ASI into an ASI mask: */"
	    echo "  switch (asi_data) {"
	    echo "  case TME_SPARC32_ASI_UI: asi_mask_data = TME_SPARC32_ASI_MASK_UI; break;"
	    echo "  case TME_SPARC32_ASI_UD: asi_mask_data = TME_SPARC32_ASI_MASK_UD; break;"
	    echo "  case TME_SPARC32_ASI_SI: asi_mask_data = TME_SPARC32_ASI_MASK_SI; break;"
	    echo "  case TME_SPARC32_ASI_SD: asi_mask_data = TME_SPARC32_ASI_MASK_SD; break;"
	    echo "  default: asi_mask_data = TME_SPARC_ASI_MASK(asi_data); break;"
	    echo "  }"
	else
	    echo ""
	    echo "  /* if the i bit is one, use the address space in the ASI register: */"
	    echo "  if (TME_SPARC_INSN & TME_BIT(13)) {"
	    echo "    asi_data = ic->tme_sparc_ireg_asi;"
	    echo "  }"
	    echo ""
	    echo "  /* start the ASI mask: */"
	    echo "  asi_mask_data = TME_SPARC_ASI_MASK(asi_data);"
	    
	    echo ""
	    echo "  /* if this is an unpriviledged access: */"
	    echo "  if (!TME_SPARC_PRIV(ic)) {"
	    echo ""
	    echo "    /* this is a priviledge violation if bit 7 of the ASI is zero: */"
	    echo "    if (asi_data < 0x80) {"
	    echo "      TME_SPARC_INSN_TRAP(TME_SPARC_TRAP_privileged_instruction);"
	    echo "    }"
	    echo "  }"
	fi
	echo ""
	echo "  return (asi_mask_data);"
	echo "}"
    fi

    # permute over instruction:
    #
    for insn in \
	add \
	addcc \
	sub \
	subcc \
	or \
	orcc \
	orn \
	orncc \
	and \
	andcc \
	andn \
	andncc \
	xor \
	xorcc \
	xnor \
	xnorcc \
	addx \
	addxcc \
	subx \
	subxcc \
	taddcc taddcctv \
	tsubcc tsubcctv \
	umul umulcc smul smulcc \
	udiv udivcc sdiv sdivcc \
	sll \
	srl \
	sra \
	ldb stb \
	ldh sth \
	ld st \
	ldd std \
	ldstub ldstuba swap swapa \
	ldba stba \
	ldha stha \
	lda sta \
	ldda stda \
	jmpl \
	ldf lddf ldfsr \
	stf stdf stfsr \
	mulscc \
	; do

	# if we're making the header, just emit declarations:
	#
	if $header; then
	    echo "TME_SPARC_FORMAT3_DECL(tme_sparc${arch}_${insn}, tme_uint${arch}_t);"
	    continue
	fi

	# an ALU instruction:
	#
	case ${insn} in
	add | sub | or | orn | and | andn | xor | xnor | \
	addx | subx | umul | smul | udiv | sdiv)
	    cc=false
	    ;;
	addcc | subcc | orcc | orncc | andcc | andncc | xorcc | xnorcc | \
	addxcc | subxcc | umulcc | smulcc | udivcc | sdivcc | \
	taddcc | tsubcc | taddcctv | tsubcctv | \
	mulscc)
	    cc=true
	    ;;
	*)
	    cc=
	    ;;
	esac
	if test "x${cc}" != x; then

	    # characterize each function:
	    #
	    sign=u ; size_src=${arch} ; size_dst=${arch} ; arith=logical ; with_c= ; tagged=
	    case "${insn}" in
	    add  | addcc)   op='src1 + src2' ; arith=add ;;
	    sub  | subcc)   op='src1 - src2' ; arith=sub ;;
	    or   | orcc)    op='src1 | src2' ;;
	    orn  | orncc)   op='src1 | ~src2' ;;
	    and  | andcc)   op='src1 & src2' ;;
	    andn | andncc)  op='src1 & ~src2' ;;
	    xor  | xorcc)   op='src1 ^ src2' ;;
	    xnor | xnorcc)  op='src1 ^ ~src2' ;;
	    addx | addxcc)  op='src1 + src2' ; arith=add ; with_c=+ ;;
	    subx | subxcc)  op='src1 - src2' ; arith=sub ; with_c=- ;;
	    taddcc)         op='src1 + src2' ; arith=add ; tagged=x ;;
	    taddcctv)       op='src1 + src2' ; arith=add ; tagged=tv ;;
	    tsubcc)         op='src1 - src2' ; arith=sub ; tagged=x ;;
	    tsubcctv)       op='src1 - src2' ; arith=sub ; tagged=tv ;;
	    umul | umulcc)  arith=mul ; size_src=32 ;;
	    smul | smulcc)  arith=mul ; size_src=32 ; sign= ;;
	    udiv | udivcc)  arith=udiv ; size_src=32 ; size_dst=32 ;;
	    sdiv | sdivcc)  arith=sdiv ; size_src=32 ; size_dst=32 ; sign= ;;
	    mulscc)	    arith=add ; size_src=32 ; size_dst=32 ;;
	    *) echo "$0 internal error: unknown ALU function ${insn}" 1>&2 ; exit 1 ;;
	    esac

	    # open the function:
	    #
	    echo ""
	    echo "/* this does a sparc${arch} \"${insn} SRC1, SRC2, DST\": */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"

	    # declare our locals:
	    #
	    echo "  tme_${sign}int${size_src}_t src1;"
	    echo "  tme_${sign}int${size_src}_t src2;"
	    echo "  tme_${sign}int${size_dst}_t dst;"
	    case "${insn}" in
	    umul* | smul* | udiv* | sdiv*)
		echo "  tme_${sign}int64_t val64;"
		;;
	    mulscc)
		echo "  tme_uint32_t y;"
		;;
	    esac
	    if ${cc}; then
		echo "  tme_uint32_t cc;"
	    fi

	    echo ""
	    echo "  /* get the operands: */"
	    echo "  src1 = (tme_${sign}int${arch}_t) TME_SPARC_FORMAT3_RS1;"
	    echo "  src2 = (tme_${sign}int${arch}_t) TME_SPARC_FORMAT3_RS2;"

	    echo ""
	    echo "  /* perform the operation: */"
	    case "${insn}" in
	    umul | umulcc | smul | smulcc)
		echo "  val64 = (((tme_${sign}int64_t) src1) * src2);"
		echo "  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y${reg32_shift}) = (((tme_uint64_t) val64) >> 32);"
		echo "  dst = ((tme_${sign}int64_t) val64);"
		;;
	    udiv | udivcc | sdiv | sdivcc)
		echo "  val64 = ((((tme_uint64_t) ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y${reg32_shift})) << 32) | ((tme_uint32_t) src1));"
		echo "  val64 /= src2;"
		echo "  /* XXX FIXME - overflow handling is missing here: */"
		echo "  dst = val64;"
		;;
	    mulscc)
		echo ""
		echo "  /* \"(1) The multiplier is established as r[rs2] if the i field is zero, or "
		echo "     sign_ext(simm13) if the i field is one.\""
		echo ""
		echo "     \"(3) If the least significant bit of the Y register = 1, the shifted"
		echo "     value from step (2) is added to the multiplier. If the LSB of the"
		echo "     Y register = 0, then 0 is added to the shifted value from step (2).\" */"
		echo "  y = ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y${reg32_shift});"
		echo "  if ((y & 1) == 0) {"
		echo "    src2 = 0;"
		echo "  }"
		echo ""
		echo "  /* \"(6) The Y register is shifted right by one bit, with the LSB of the"
		echo "     unshifted r[rs1] replacing the MSB of Y.\" */"
		echo "  y >>= 1;"
		echo "  if (src1 & 1) {"
		echo "    y += 0x80000000;"
		echo "  }"
		echo "  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y${reg32_shift}) = y;"
		echo ""
		echo "  /* \"(2) A 32-bit value is computed by shifting r[rs1] right by one"
		echo "     bit with (N xor V) from the PSR replacing the high-order bit."
		echo "     (This is the proper sign for the previous partial product.)\" */"
		echo "  src1 >>= 1;"
		echo "  if (((ic->${ccr_ireg} ^ (ic->${ccr_ireg} * (TME_SPARC${ccr}_ICC_N / TME_SPARC${ccr}_ICC_V))) & TME_SPARC${ccr}_ICC_N) != 0) {"
		echo "    src1 += 0x80000000;"
		echo "  }"
		echo ""
		echo "  /* \"(4) The sum from step (3) is written into r[rd].\" */"
		echo "  dst = src1 + src2;"
		echo ""
		echo "  /* \"(5) The integer condition codes, icc, are updated according to the"
		echo "     addition performed in step (3).\" */"
		;;
	    *)
		echo "  dst = ${op};"
		if test "x${with_c}" != x; then
		    echo "  dst ${with_c}= ((ic->${ccr_ireg} & TME_SPARC${ccr}_ICC_C) != 0);"
		fi
	    esac

	    # unless this is a tagged-and-trap-on-overflow operation:
	    #
	    if test "x${tagged}" != xtv; then
		echo ""
		echo "  /* store the destination: */"
		echo "  TME_SPARC_FORMAT3_RD = (tme_${sign}int${arch}_t) dst;"
	    fi

	    # if this instruction modifies the condition codes:
	    #
	    if ${cc}; then

		echo ""
		echo "  /* set Z if the destination is zero: */"
		echo -n "  cc = ((dst == 0) * (TME_SPARC${ccr}_ICC_Z"
		if test ${arch} = 64; then
		    echo -n " + TME_SPARC${ccr}_XCC_Z"
		fi
		echo "));"

		# set the 32-bit, and possibly the 64-bit, condition codes:
		#
		arch_cc=16
		while test `expr ${arch_cc} \< ${arch}` = 1; do
		    arch_cc=`expr ${arch_cc} \* 2`

		    case ${arch_cc} in
		    32) xcc=ICC ;;
		    64) xcc=XCC ;;
		    esac

		    if test `expr ${arch_cc} \<= ${size_dst}` = 1 || test "x${sign}" = xs; then
			echo ""
			echo "  /* set N if the destination is negative: */"
			echo "  cc += ((((tme_int${arch_cc}_t) dst) < 0) * TME_SPARC${ccr}_${xcc}_N);"
		    fi

		    case $arith in
		    add)
			ones="(((tme_${sign}int${arch_cc}_t) 0) - 1)"

			echo ""
			echo "  /* if the operands are the same sign, and the destination has"
			echo "     a different sign, set V: */"
			echo "  cc += ((((tme_int${arch_cc}_t) ((src2 ^ dst) & (src1 ^ (src2 ^ ${ones})))) < 0) * TME_SPARC${ccr}_${xcc}_V);"

			echo ""
			echo "  /* if src1 and src2 both have the high bit set, or if dst does"
			echo "     not have the high bit set and either src1 or src2 does, set C: */"
			echo "  cc += (((tme_int${arch_cc}_t) (((tme_uint${arch_cc}_t) (src1 & src2)) | ((((tme_uint${arch_cc}_t) dst) ^ ${ones}) & ((tme_uint${arch_cc}_t) (src1 | src2))))) < 0) * TME_SPARC${ccr}_${xcc}_C;"
			;;
		    sub) 

			echo ""
			echo "  /* if the operands are different signs, and the destination has"
			echo "     a different sign from the first operand, set V: */"
			echo "  cc += ((((tme_int${arch_cc}_t) ((src1 ^ src2) & (src1 ^ dst))) < 0) * TME_SPARC${ccr}_${xcc}_V);"

			echo ""
			echo "  /* if src2 is greater than src1, set C: */"
			echo -n "  cc += ((((tme_uint${arch_cc}_t) src2) > ((tme_uint${arch_cc}_t) src1))"
			if test "x${with_c}" != x; then
			    echo -n " || (((tme_uint${arch_cc}_t) src2) == ((tme_uint${arch_cc}_t) src1) && (ic->${ccr_ireg} & TME_SPARC${ccr}_ICC_C))"
			fi
			echo ") * TME_SPARC${ccr}_${xcc}_C;"
			;;
		    logical | mul)
			;;
		    udiv)
			;;
		    sdiv)
			;;
		    *) echo "$0 internal error: unknown arithmetic type ${arith}" 1>&2 ; exit 1 ;;
		    esac
		done
		
		# if this is a tagged operation:
		#
		if test "x${tagged}" != x; then

		    echo ""
		    echo "  /* set V if bits zero or one of src1 or src2 are set: */"
		    echo "  cc |= ((((src1 | src2) & 3) != 0) * TME_SPARC${ccr}_ICC_V);"

		    # if this is a tagged-and-trap-on-overflow operation:
		    #
		    if test "x${tagged}" = xtv; then

			echo ""
			echo "  /* trap on a tagged overflow: */"
			echo "  if (cc & TME_SPARC${ccr}_ICC_V) {"
			echo "    tme_sparc${arch}_trap(ic, TME_SPARC_TRAP_tag_overflow);"
			echo "  }"

			echo "  /* store the destination: */"
			echo "  TME_SPARC_FORMAT3_RD = (tme_${sign}int${arch}_t) dst;"
		    fi
		fi

		echo ""
		echo "  /* set the condition codes: */"
		echo -n "  ic->${ccr_ireg} = "
		if test ${arch} = 32; then
		    echo -n "(ic->${ccr_ireg} & ~TME_SPARC32_PSR_ICC) | "
		fi
		echo "cc;"
	    fi

	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# a shift instruction:
	#
	case ${insn} in
	sll | srl | sra)

	    # get the sign of this shift:
	    #
	    if test ${insn} = sra; then sign= ; else sign=u; fi

	    echo ""
	    echo "/* the sparc${arch} ${insn} function: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  tme_${sign}int${arch}_t dst;"
	    echo "  unsigned int count;"
	    echo ""
	    echo "  /* get the value and the shift count: */"
	    echo "  dst = TME_SPARC_FORMAT3_RS1;"
	    echo "  count = TME_SPARC_FORMAT3_RS2;"

	    # if we're on sparc64:
	    #
	    if test ${arch} = 64; then

		echo ""
		echo "  /* if the X bit is clear: */"
		echo "  if ((TME_SPARC_INSN & TME_BIT(12)) == 0) {"
		echo ""
		echo "    /* limit the count: */"
		echo "    count %= 32;"
		if test ${insn} != sll; then
		    echo ""
		    echo "  /* clip the value to 32 bits: */"
		    echo "  dst = (tme_${sign}int32_t) dst;"
		fi
		echo "  }"
	    fi

	    echo ""
	    echo "  /* limit the count: */"
	    echo "  count %= ${arch};"
	    echo ""
	    echo "  /* do the shift: */"
	    if test "${insn}" = sra; then
		echo "#ifdef SHIFTSIGNED_INT${arch}_T"
	    fi
	    echo "#if (SHIFTMAX_INT${arch}_T < (${arch} - 1))"
	    echo "#error \"cannot do full shifts of a tme_int${arch}_t\""
	    echo "#endif /* (SHIFTMAX_INT${arch}_T < (${arch} - 1)) */"
	    if test ${insn} = sll; then
		echo "  dst <<= count;"
	    else
		echo "  dst >>= count;"
	    fi
	    if test "${insn}" = sra; then
		echo "#else  /* !SHIFTSIGNED_INT${arch}_T */"
		echo "  for (; count-- > 0; ) {"
		echo "    dst = (dst & ~((tme_${sign}int${arch}_t) 1)) / 2;"
		echo "  }"
		echo "#endif /* !SHIFTSIGNED_INT${arch}_T */"
	    fi
	    
	    echo ""
	    echo "  /* store the destination: */"
	    echo "  TME_SPARC_FORMAT3_RD = dst;"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	    ;;
	esac

	# a load or store instruction:
	#
	size=
	case "${insn}" in
	ldb | stb | ldstub | ldba | stba | ldstuba) size=8 ;;
	ldh | sth | ldha | stha) size=16 ;;
	ld | st | swap | lda | sta | swapa) size=32 ;;
	ldd | std | ldda | stda) size=32 ;;
	esac
	if test "x${size}" != x; then

	    # set the alternate space indication:
	    #
	    case "${insn}" in
	    *a) alternate=true ;;
	    *) alternate=false ;;
	    esac

	    # set the atomic and double indications:
	    #
	    atomic=false
	    double=false
	    case "${insn}" in
	    ldstub | ldstuba | swap | swapa) atomic=true ;;
	    ldd* | std*) double=true ; size=64 ;;
	    esac

	    # if this is only a load, we are reading, otherwise we are writing:
	    #
	    cycle=write
	    capcycle=WRITE
	    slow=store
	    case "${insn}" in
	    ldstub*) ;;
	    ld*) 
		cycle=read
		capcycle=READ
		slow=load
		;;
	    esac

	    # start the instruction:
	    #
	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"

	    # our locals:
	    #
	    if ${alternate}; then
		echo "  tme_uint32_t asi_mask_data;"
		asi_mask_data=asi_mask_data
	    else
		asi_mask_data="ic->tme_sparc_asi_mask_data"
	    fi
	    echo "  tme_uint${arch}_t address;"
	    echo "  struct tme_sparc_tlb *dtlb;"
	    echo -n "  "
	    if test ${slow} = load; then echo -n "const "; fi
	    echo "tme_shared tme_uint8_t *memory;"
	    echo "  tme_uint${arch}_t value;"

	    if ${alternate}; then
		echo ""
		echo "  /* get the alternate ASI mask: */"
		echo "  asi_mask_data = _tme_sparc${arch}_alternate_asi_mask(ic);"
	    fi

	    echo ""
	    echo "  /* get the address: */"
	    echo "  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;"
		
	    echo ""
	    echo "#ifdef _TME_SPARC_STATS"
	    echo "  /* track statistics: */"
	    echo "  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;"
	    echo "#endif /* _TME_SPARC_STATS */"

	    # if this is some kind of a store, except for an ldstub:
	    #
	    case "${insn}" in
	    std*)
		echo ""
		echo "  /* log the values stored: */"
		# XXX FIXME - we can't verify a std yet:
		#
		echo "  tme_sparc_log(ic, 1000, TME_OK, "
		echo "               (TME_SPARC_LOG_HANDLE(ic),"
		echo "                _(\"${insn}\t0x%02x:0x%0"`expr ${arch} / 4`"x:\t0x%08x 0x%08x\"),"
		echo "                TME_SPARC_ASI_MASK_WHICH(${asi_mask_data}),"
		echo "                address,"
		echo "                (tme_uint32_t) TME_SPARC_FORMAT3_RD,"
		echo "                (tme_uint32_t) TME_SPARC_FORMAT3_RD_ODD));"
		;;
	    st* | swap*)
		echo ""
		echo "  /* log the value stored: */"
		echo "  tme_sparc_verify_mem${size}(ic, ${asi_mask_data}, address, (tme_uint${size}_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);"
		echo "  tme_sparc_log(ic, 1000, TME_OK, "
		echo "               (TME_SPARC_LOG_HANDLE(ic),"
		echo "                _(\"${insn}\t0x%02x:0x%0"`expr ${arch} / 4`"x:\t0x%0"`expr ${size} / 4`"x\"),"
		echo "                TME_SPARC_ASI_MASK_WHICH(${asi_mask_data}),"
		echo "                address,"
		echo "                (tme_uint${size}_t) TME_SPARC_FORMAT3_RD));"
		;;
	    esac

	    echo ""
	    echo "  /* get and busy the DTLB entry: */"
	    echo "  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);"
	    echo "  tme_sparc_tlb_busy(dtlb);"

	    echo ""
	    echo "  /* assume that this DTLB applies and allows fast transfers: */"
	    echo "  memory = dtlb->tme_sparc_tlb_emulator_off_${cycle};"

	    echo ""
	    echo "  /* we must call the slow ${slow} function if: */"
	    echo "  if (__tme_predict_false("
	    echo ""
	    echo "                          /* the DTLB entry is invalid: */"
	    echo "                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)"
	    echo ""
	    echo "                          /* the DTLB entry does not cover the needed addresses: */"
	    echo "                          || (dtlb->tme_sparc_tlb_addr_first > address)"
	    echo "                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((${size} / 8) - 1)))"
	    echo ""
	    echo "                          /* the DTLB entry does not cover the needed address space: */"
	    echo "                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ${asi_mask_data}))"
	    echo ""
	    echo "                          /* the DTLB entry does not allow fast transfers: */"
	    if $atomic; then
		echo "                          || (memory != dtlb->tme_sparc_tlb_emulator_off_read)"
	    fi
	    echo "                          || (memory == TME_EMULATOR_OFF_UNDEF)"
	    if test ${size} != 8; then
		echo ""
		echo "                          /* the address is misaligned: */"
		echo "                          || ((address % (${size} / 8)) != 0)"
	    fi
	    if ${double}; then
		echo ""
		echo "                          /* the destination register number is odd: */"
		echo "                          || ((TME_SPARC_INSN & TME_BIT(25)) != 0)"
	    fi
	    echo ""
	    echo "                          )) {"

	    echo ""
	    echo "    /* call the slow ${slow} function: */"
	    echo "    memory = tme_sparc${arch}_${slow}(ic,"
	    echo "                               address,"
	    if test ${slow} = store; then
		echo "                               &TME_SPARC_FORMAT3_RD,"
	    fi
	    echo -n "                               ("
	    if ${atomic}; then
		echo "TME_SPARC_SLOW_FLAG_ATOMIC"
		echo -n "                                | "
	    fi
	    if ${alternate}; then
		echo "TME_SPARC_SLOW_FLAG_A"
		echo -n "                                | "
	    fi
	    echo "(${size} / 8)));"
	    
	    if test ${slow} = store; then
		echo ""
		echo "    /* if the slow ${slow} function did the transfer, return now: */"
		echo "    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {"
		echo "      tme_sparc_tlb_unbusy(dtlb);"
		echo "      TME_SPARC_INSN_OK;"
		echo "    }"
	    fi
	    echo "  }"

	    echo ""
	    echo "  /* do the fast transfer: */"
	    echo "  memory += address;"

	    # dispatch on the instruction:
	    #
	    case "${insn}" in
	    ldd*)
		if test ${arch} = 32; then
		    echo "  value = tme_memory_bus_read32(((const tme_shared tme_uint32_t *) memory) + 0, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t) * 2, sizeof(tme_uint${arch}_t));"
		    echo "  TME_SPARC_FORMAT3_RD = tme_betoh_u32(value);"
		    echo "  value = tme_memory_bus_read32(((const tme_shared tme_uint32_t *) memory) + 1, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint${arch}_t));"
		    echo "  TME_SPARC_FORMAT3_RD_ODD = tme_betoh_u32(value);"
		else
		    echo "$PROG fatal: need ${insn} support for sparc${arch}" 1>&2
		    exit 1
		fi
		;;
	    std*)
		if test ${arch} = 32; then
		    echo "  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);"
		    echo "  tme_memory_bus_write32(((tme_shared tme_uint32_t *) memory) + 0, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t) * 2, sizeof(tme_uint${arch}_t));"
		    echo "  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD_ODD);"
		    echo "  tme_memory_bus_write32(((tme_shared tme_uint32_t *) memory) + 1, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint${arch}_t));"
		else
		    echo "$PROG fatal: need ${insn} support for sparc${arch}" 1>&2
		    exit 1
		fi
		;;
	    ldstub*)
		echo "  value = tme_memory_atomic_xchg8(memory, 0xff, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t));"
		;;
	    swap*)
		echo "  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);"
		echo "  value = tme_memory_atomic_xchg32((tme_shared tme_uint${size}_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t));"
		;;
	    ld*)
		echo "  value = tme_memory_bus_read${size}((const tme_shared tme_uint${size}_t *) memory, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint${size}_t), sizeof(tme_uint${arch}_t));"
		if test ${size} != 8; then
		    echo "  value = tme_betoh_u${size}(value);"
		fi
		;;
	    st*)
		if test ${size} = 8; then swap_st= ; else swap_st="tme_htobe_u${size}"; fi
		echo "  value = ${swap_st}(TME_SPARC_FORMAT3_RD);"
		echo "  tme_memory_bus_write${size}((tme_shared tme_uint${size}_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint${size}_t), sizeof(tme_uint${arch}_t));"
		;;
	    *) echo "$PROG internal error: unknown memory insn ${insn}" 1>&2 ; exit 1 ;;
	    esac

	    echo ""
	    echo "  /* unbusy the DTLB entry: */"
	    echo "  tme_sparc_tlb_unbusy(dtlb);"

	    case "${insn}" in
	    ldd*) ;;
	    ld* | swap*)
		if test `expr ${size} \< ${arch}` = 1; then
		    echo ""
		    echo "  /* possibly sign-extend the loaded value: */"
		    echo "  if (TME_SPARC_INSN & TME_BIT(22)) {"
		    echo "    value = (tme_uint${arch}_t) (tme_int${arch}_t) (tme_int${size}_t) value;"
		    echo "  }"
		fi
		echo ""
		echo "  /* set the loaded value: */"
		echo "  TME_SPARC_FORMAT3_RD = value;"
		;;
	    esac
		
	    # if this is some kind of a load, log the value loaded:
	    #
	    case ${insn} in
	    ldd*)
		echo ""
		echo "  /* log the value loaded: */"
		# XXX FIXME - we can't verify a ldd yet:
		#
		echo "  tme_sparc_log(ic, 1000, TME_OK,"
		echo "               (TME_SPARC_LOG_HANDLE(ic),"
		echo "                _(\"${insn}\t0x%02x:0x%0"`expr ${arch} / 4`"x:\t0x%08x 0x%08x\"),"
		echo "                TME_SPARC_ASI_MASK_WHICH(${asi_mask_data}),"
		echo "                address,"
		echo "                (tme_uint32_t) TME_SPARC_FORMAT3_RD,"
		echo "                (tme_uint32_t) TME_SPARC_FORMAT3_RD_ODD));"
		;;
	    ld* | ldstub* | swap*)
		echo ""
		echo "  /* log the value loaded: */"
		echo "  tme_sparc_verify_mem${size}(ic, ${asi_mask_data}, address, (tme_uint${size}_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);"
		echo "  tme_sparc_log(ic, 1000, TME_OK,"
		echo "               (TME_SPARC_LOG_HANDLE(ic),"
		echo "                _(\"${insn}\t0x%02x:0x%0"`expr ${arch} / 4`"x:\t0x%0"`expr ${arch} / 4`"x\"),"
		echo "                TME_SPARC_ASI_MASK_WHICH(${asi_mask_data}),"
		echo "                address,"
		echo "                TME_SPARC_FORMAT3_RD));"
		;;
	    esac

	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the jmpl instruction:
	#
	if test ${insn} = jmpl; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  tme_uint${arch}_t pc_next_next;"
	    echo ""
	    echo "  /* \"The JMPL instruction causes a register-indirect delayed control"
	    echo "     transfer to the address given by r[rs1] + r[rs2] if the i field is"
	    echo "     zero, or r[rs1] + sign_ext(simm13) if the i field is one. The JMPL"
	    echo "     instruction copies the PC, which contains the address of the JMPL"
	    echo "     instruction, into register r[rd]. If either of the low-order two"
	    echo "     bits of the jump address is nonzero, a mem_address_not_aligned"
	    echo "     trap occurs.\" */"
	    echo ""
	    echo "  pc_next_next = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;"
	    echo "  if (__tme_predict_false((pc_next_next % sizeof(tme_uint32_t)) != 0)) {"
	    echo "    TME_SPARC_INSN_TRAP(TME_SPARC_TRAP_mem_address_not_aligned);"
	    echo "  }"
	    echo ""
	    echo "  /* write the PC of the jmpl into r[rd]: */"
	    echo "  TME_SPARC_FORMAT3_RD = ic->tme_sparc_ireg_uint${arch}(TME_SPARC_IREG_PC);"
	    echo ""
	    echo "  /* log an indirect call instruction, which has 15 (%o7) for rd: */"
	    echo "  if (TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD) == 15) {"
	    echo "    tme_sparc_log(ic, 250, TME_OK,"
	    echo "                  (TME_SPARC_LOG_HANDLE(ic),"
	    echo "                   _(\"call 0x%08x\"),"
	    echo "                   pc_next_next));"
	    echo "  }"
	    echo ""
	    echo "  /* log a ret or retl instruction, which has 0 (%g0) for rd,"
	    echo "     either 31 (%i7) or 15 (%o7) for rs1, and 8 for simm13: */"
	    echo "  else if ((TME_SPARC_INSN | (16 << 14))"
	    echo "           == ((tme_uint32_t) (0x2 << 30) | (0 << 25) | (0x38 << 19) | (31 << 14) | (0x1 << 13) | 8)) {"
	    echo "    tme_sparc_log(ic, 250, TME_OK,"
	    echo "                  (TME_SPARC_LOG_HANDLE(ic),"
	    echo "                   _(\"retl 0x%08x\"),"
	    echo "                   pc_next_next));"
	    echo "  }"
	    echo ""
	    echo "  /* set the delayed control transfer: */"
	    echo "  ic->tme_sparc_ireg_uint${arch}(TME_SPARC_IREG_PC_NEXT_NEXT) = pc_next_next;"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the ldf instruction:
	#
	if test ${insn} = ldf; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  unsigned int fpreg_number;"
	    echo ""
	    echo "  TME_SPARC_INSN_FPU;"
	    echo ""
	    echo "  /* decode rd: */"
	    echo "  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);"
	    echo ""
	    echo "  /* make sure this floating-point register is single-precision: */"
	    echo "  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_SINGLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);"
	    echo ""
	    echo "  /* do the load: */"
	    echo "  tme_sparc${arch}_ld(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}));"
	    echo ""
	    echo "  /* set the floating-point register value: */"
	    echo "  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_format = TME_FLOAT_FORMAT_IEEE754_SINGLE;"
	    echo "  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_value_ieee754_single"
	    echo "    = ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift});"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the stf instruction:
	#
	if test ${insn} = stf; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  unsigned int fpreg_number;"
	    echo "  const tme_uint32_t *value_single;"
	    echo "  tme_uint32_t value_single_buffer;"
	    echo ""
	    echo "  TME_SPARC_INSN_FPU_STORE(sizeof(tme_uint32_t));"
	    echo ""
	    echo "  /* decode rd: */"
	    echo "  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);"
	    echo ""
	    echo "  /* make sure this floating-point register is single-precision: */"
	    echo "  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_SINGLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);"
	    echo ""
	    echo "  /* get this single floating-point register in IEEE754 single-precision format: */"
	    echo "  value_single = tme_ieee754_single_value_get(&ic->tme_sparc_fpu_fpregs[fpreg_number], &value_single_buffer);"
	    echo ""
	    echo "  /* set the floating-point register value: */"
	    echo "  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}) = *value_single;"
	    echo ""
	    echo "  /* do the store: */"
	    echo "  tme_sparc${arch}_st(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}));"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the lddf instruction:
	#
	if test ${insn} = lddf; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  unsigned int fpreg_number;"
	    echo ""
	    echo "  TME_SPARC_INSN_FPU;"
	    echo ""
	    echo "  /* decode rd: */"
	    echo "  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);"
	    echo ""
	    echo "  /* make sure rd is aligned: */"
	    echo "  if (!tme_sparc_fpu_fpreg_aligned(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE)) {"
	    echo "    fpreg_number -= 1;"
	    echo "  }"
	    echo ""
	    echo "  /* make sure that the double floating-point register is double-precision: */"
	    echo "  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);"
	    echo ""
	    echo "  /* do the load: */"
	    echo "  tme_sparc${arch}_ldd(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}));"
	    echo ""
	    echo "  /* set the double floating-point register value: */"
	    echo "  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_format = TME_FLOAT_FORMAT_IEEE754_DOUBLE;"
	    echo "  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_value_ieee754_double.tme_value64_uint32_hi"
	    echo "    = ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX${reg32_shift}) + 0);"
	    echo "  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_value_ieee754_double.tme_value64_uint32_lo"
	    echo "    = ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX${reg32_shift}) + 1);"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the stdf instruction:
	#
	if test ${insn} = stdf; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  unsigned int fpreg_number;"
	    echo "  const union tme_value64 *value_double;"
	    echo "  union tme_value64 value_double_buffer;"
	    echo ""
	    echo "  TME_SPARC_INSN_FPU_STORE(sizeof(tme_uint32_t) * 2);"
	    echo ""
	    echo "  /* decode rd: */"
	    echo "  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);"
	    echo ""
	    echo "  /* make sure rd is aligned: */"
	    echo "  if (!tme_sparc_fpu_fpreg_aligned(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE)) {"
	    echo "    fpreg_number -= 1;"
	    echo "  }"
	    echo ""
	    echo "  /* make sure the double floating-point register is double-precision: */"
	    echo "  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);"
	    echo ""
	    echo "  /* get this double floating-point register in IEEE754 double-precision format: */"
	    echo "  value_double = tme_ieee754_double_value_get(&ic->tme_sparc_fpu_fpregs[fpreg_number], &value_double_buffer);"
	    echo ""
	    echo "  /* set the floating-point register value: */"
	    echo "  ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX${reg32_shift}) + 0)"
	    echo "    = value_double->tme_value64_uint32_hi;"
	    echo "  ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX${reg32_shift}) + 1)"
	    echo "    = value_double->tme_value64_uint32_lo;"
	    echo ""
	    echo "  /* do the store: */"
	    echo "  tme_sparc${arch}_std(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}));"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the ldfsr instruction:
	#
	if test ${insn} = ldfsr; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  tme_uint32_t fsr;"
	    echo ""
	    echo "  TME_SPARC_INSN_FPU;"
	    echo ""
	    echo "  /* do the load: */"
	    echo "  tme_sparc${arch}_ld(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}));"
	    echo ""
	    echo "  /* update the FSR: */"
	    echo "  fsr = ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift});"
	    echo "  /* \"An LDFSR instruction does not affect ftt.\" */"
	    echo "  /* \"The LDFSR instruction does not affect qne.\" */"
	    echo "  fsr &= ~(TME_SPARC_FSR_VER | TME_SPARC_FSR_FTT | TME_SPARC_FSR_QNE);"
	    echo "  ic->tme_sparc_fpu_fsr = (ic->tme_sparc_fpu_fsr & (TME_SPARC_FSR_VER | TME_SPARC_FSR_FTT | TME_SPARC_FSR_QNE)) | fsr;"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the stfsr instruction:
	#
	if test ${insn} = stfsr; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo ""
	    echo "  TME_SPARC_INSN_FPU_STORE(sizeof(ic->tme_sparc_fpu_fsr));"
	    echo ""
	    echo "  /* set the FSR value to store: */"
	    echo "  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}) = ic->tme_sparc_fpu_fsr;"
	    echo ""
	    echo "  /* do the store: */"
	    echo "  tme_sparc${arch}_st(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX${reg32_shift}));"
	    echo ""
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

	# the fpop1 and fpop2 instructions:
	#
	if test ${insn} = fpop1 || test ${insn} = fpop2; then

	    echo ""
	    echo "/* this does a sparc${arch} ${insn}: */"
	    echo "TME_SPARC_FORMAT3(tme_sparc${arch}_${insn}, tme_uint${arch}_t)"
	    echo "{"
	    echo "  TME_SPARC_INSN_FPU;"
	    echo "  tme_sparc_fpu_${insn}(ic);"
	    echo "  TME_SPARC_INSN_OK;"
	    echo "}"
	fi

    done

    # the slow load and store functions:
    #
    for slow in load store; do

	if test ${slow} = load; then
	    cycle="read"
	    capcycle="READ"
	    if $header; then
		echo "const tme_shared tme_uint8_t *tme_sparc${arch}_${slow} _TME_P((struct tme_sparc *, tme_uint${arch}_t, unsigned int));"
		continue
	    fi
	else
	    cycle="write"
	    capcycle="WRITE"
	    if $header; then
		echo "tme_shared tme_uint8_t *tme_sparc${arch}_${slow} _TME_P((struct tme_sparc *, tme_uint${arch}_t, const tme_uint${arch}_t *, unsigned int));"
		continue
	    fi
	fi

	echo ""
	echo "/* this does a slow ${slow}: */"
	if test ${slow} = load; then echo -n "const "; fi
	echo "tme_shared tme_uint8_t *"
	echo "tme_sparc${arch}_${slow}(struct tme_sparc *ic, "
	echo "                  tme_uint${arch}_t address, "
	if test ${slow} = store; then
	    echo "                  const tme_uint${arch}_t * const _rd,"
	fi
	echo "                  const unsigned int flags)"
	echo "{"

	# our locals:
	#
	echo "  unsigned int size;"
	echo "  tme_uint32_t asi_mask_data;"
	echo "  struct tme_sparc_tlb *dtlb;"
	echo "  tme_bus_addr_t physical_address;"
	echo "  int shift;"
	echo "  struct tme_bus_cycle cycle;"
	echo "  unsigned int transferred, resid, cycle_size;"
	echo "  unsigned int trap;"
	echo "  int err;"
	if test ${slow} = store; then
	    echo "  tme_uint${arch}_t stored_registers[2];"
	    echo "  const tme_uint8_t *buffer;"
	    buffer=buffer
	else
	    buffer="&ic->tme_sparc_memory_buffer[0]"
	fi

	echo ""
	echo "  /* get the transfer size.  we can do at most a 64-bit transfer: */"
	echo "  size = (flags % (sizeof(tme_uint64_t) * 2));"

	echo ""
	echo "  /* get the DTLB entry.  our caller has already busied it: */"
	echo "  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);"

	echo ""
	echo "  /* if the address is not aligned: */"
	echo "  if (__tme_predict_false((address & (size - 1)) != 0)) {"
	echo "    tme_sparc_tlb_unbusy(dtlb);"
	echo "    tme_sparc${arch}_trap(ic, TME_SPARC_TRAP_mem_address_not_aligned);"
	echo "  }"

	echo ""
	echo "  /* if this is a ldd or a std (and not an lddf or an stdf)"
	echo "     and the destination register address is odd: */"
	echo "  /* NB: we detect lddf and stdf by testing bit 24 in the"
	echo "     instruction word: */"
	echo "  if (__tme_predict_false(size == (sizeof(tme_uint32_t) * 2)"
	echo "                          && (TME_SPARC_INSN & TME_BIT(25)) != 0"
	echo "                          && (TME_SPARC_INSN & TME_BIT(24)) == 0)) {"
	echo "    tme_sparc_tlb_unbusy(dtlb);"
	echo "    tme_sparc${arch}_trap(ic, TME_SPARC_TRAP_illegal_instruction);"
	echo "  }"
	
	echo ""
	echo "  /* get the ASI and its mask: */"
	echo "  asi_mask_data = ic->tme_sparc_asi_mask_data;"
	echo "  if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_INSN) != 0)) {"
	echo "    asi_mask_data = ic->tme_sparc_asi_mask_insn;"
	echo "  }"
	echo "  if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_A) != 0)) {"
	echo "    asi_mask_data = _tme_sparc${arch}_alternate_asi_mask(ic);"
	echo "  }"
			
	if test ${slow} = store; then
	    echo ""
	    echo "  /* store big-endian versions of the registers to store in"
	    echo "     a buffer.  we always assume that this is a std and copy"
	    echo "     r[rd] and r[rd + 1] into the buffer: */"
	    echo "  stored_registers[0] = tme_htobe_u${arch}(TME_SPARC_FORMAT3_RD);"
	    echo "  stored_registers[1] = tme_htobe_u${arch}(TME_SPARC_FORMAT3_RD_ODD);"
	    echo ""
	    echo "  /* make the initial pointer into the buffer: */"
	    echo "  buffer = (const tme_uint8_t *) stored_registers;"
	    echo "  if (size < sizeof(tme_uint32_t)) {"
	    echo "    buffer += sizeof(tme_uint32_t) - size;"
	    echo "  }"
	fi
	echo ""
	echo "  /* loop until the ${slow} is completed: */"
	echo "  trap = TME_SPARC_TRAP_none;"
	echo "  transferred = 0;"
	echo "  do {"
	echo ""
	echo "    /* while the DTLB entry is invalid, or does not cover this address"
	echo "       and address space, or if it does not allow for slow or fast ${cycle}s: */"
	echo "    for (; (tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)"
	echo "            || (dtlb->tme_sparc_tlb_addr_first > address)"
	echo "            || (dtlb->tme_sparc_tlb_addr_last < address)"
	echo "            || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))"
	echo "            || (dtlb->tme_sparc_tlb_emulator_off_${cycle} == TME_EMULATOR_OFF_UNDEF"
	echo "                && (dtlb->tme_sparc_tlb_cycles_ok & TME_BUS_CYCLE_${capcycle}) == 0)); ) {"
	echo ""
	echo "      /* unbusy this DTLB entry for filling: */"
	echo "      tme_bus_tlb_unbusy_fill(&dtlb->tme_sparc_tlb_bus_tlb);"
	echo ""
	echo "      /* we never fill TLB entries on the stack because we never"
	echo "         callout multiple fills at the same time, so the global TLB"
	echo "         entry pointer always points back to the TLB entry.  this"
	echo "         also means that we do not have to call tme_bus_tlb_back()"
	echo "         after the fill: */"
	echo "      dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_global = &dtlb->tme_sparc_tlb_bus_tlb;"
	echo ""
	echo "      /* reload the DTLB entry: */"
	echo "      tme_sparc_callout_unlock(ic);"
	echo "#ifdef _TME_SPARC_STATS"
	echo "      ic->tme_sparc_stats.tme_sparc_stats_dtlb_fill++;"
	echo "#endif /* _TME_SPARC_STATS */"
	echo "      err = (*ic->_tme_sparc_bus_connection->tme_sparc_bus_tlb_fill)"
	echo "        (ic->_tme_sparc_bus_connection,"
	echo "         dtlb,"
	echo "         asi_mask_data,"
	echo "         address,"
	echo "         TME_BUS_CYCLE_${capcycle});"
	echo "      assert (err == TME_OK);"
	echo "      tme_sparc_callout_relock(ic);"
	echo ""
	echo "      /* rebusy the DTLB entry: */"
	echo "      tme_sparc_tlb_busy(dtlb);"
	echo "    }"

	echo ""
	echo "    /* if this DTLB entry allows fast ${cycle}s: */"
	echo "    if (__tme_predict_true(dtlb->tme_sparc_tlb_emulator_off_${cycle} != TME_EMULATOR_OFF_UNDEF)) {"
	echo ""
	echo "      /* if we have not transferred anything yet, and this"
	echo "         DTLB entry covers all of the addresses and allows"
	echo "         fast transfers: */"
	echo "      if (__tme_predict_true(transferred == 0"
	echo "                             && dtlb->tme_sparc_tlb_addr_last >= address + (size - 1)"
	if test ${slow} = store; then
	    echo ""
	    echo "                           && ((flags & TME_SPARC_SLOW_FLAG_ATOMIC) == 0"
	    echo -n "                               || dtlb->tme_sparc_tlb_emulator_off_read == dtlb->tme_sparc_tlb_emulator_off_${cycle})"
	fi
	echo ")) {"
	
	echo ""
	echo "        /* return and let our caller do the transfer: */"
	echo "        return (dtlb->tme_sparc_tlb_emulator_off_${cycle});"
	echo "      }"
	echo ""
	echo "      /* calculate the cycle size: */"
	echo "      cycle_size = (dtlb->tme_sparc_tlb_addr_last - address) + 1;"
	echo "      cycle_size = TME_MIN(cycle_size, sizeof(tme_uint${arch}_t) - (address % sizeof(tme_uint${arch}_t)));"
	echo "      cycle_size = TME_MIN(cycle_size, size - transferred);"
	echo "      cycle.tme_bus_cycle_size = cycle_size;"
	echo ""
	echo "      /* do a ${cycle}: */"
	echo "      tme_memory_bus_${cycle}_buffer((dtlb->tme_sparc_tlb_emulator_off_${cycle} + address),"
	echo "                                    (${buffer} + transferred),"
	echo "                                    cycle_size,"
	echo "                                    dtlb->tme_sparc_tlb_bus_rwlock,"
	echo "                                    sizeof(tme_uint8_t),"
	echo "                                    sizeof(tme_uint32_t));"
	echo "    }"
	echo ""
	echo "    /* otherwise, this DTLB entry does not allow fast ${cycle}s: */"
	echo "    else {"
	echo ""
	echo "      /* make the bus cycle structure: */"
	echo "      resid = size - transferred;"
	echo "      cycle.tme_bus_cycle_type = TME_BUS_CYCLE_${capcycle};"
	echo "      cycle.tme_bus_cycle_buffer = (tme_uint8_t *) (${buffer} + transferred);"
	echo "      cycle.tme_bus_cycle_buffer_increment = 1;"
	echo "      cycle_size = TME_MIN(resid, sizeof(tme_uint${arch}_t) - (address % sizeof(tme_uint${arch}_t)));"
	echo "      cycle.tme_bus_cycle_size = cycle_size;"
	echo "      cycle.tme_bus_cycle_port = TME_BUS_CYCLE_PORT(0, TME_BUS${arch}_LOG2);"
	echo "      cycle.tme_bus_cycle_lane_routing = "
	echo "        &tme_sparc${arch}_router[TME_SPARC_BUS_ROUTER_INDEX(TME_BUS${arch}_LOG2, cycle_size, address)];"
	echo ""
	echo "      /* form the physical address for the bus cycle handler: */"
	echo "      physical_address = dtlb->tme_sparc_tlb_addr_offset + address;"
	echo "      shift = dtlb->tme_sparc_tlb_addr_shift;"
	echo "      if (shift < 0) {"
	echo "        physical_address <<= (0 - shift);"
	echo "      }"
	echo "      else if (shift > 0) {"
	echo "        physical_address >>= shift;"
	echo "      }"
	echo "      cycle.tme_bus_cycle_address = physical_address;"

	echo ""
	echo "      /* callout the bus cycle: */"
	echo "      tme_sparc_tlb_unbusy(dtlb);"
	echo "      tme_sparc_callout_unlock(ic);"
	echo "      err = (*dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_cycle)"
	echo "           (dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_cycle_private, &cycle);"
	echo "      tme_sparc_callout_relock(ic);"
	echo "      tme_sparc_tlb_busy(dtlb);"
	echo ""
	echo "      /* if the TLB entry was invalidated before the ${slow}: */"
	echo "      if (err == EBADF"
	echo "          && tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)) {"
	echo "        cycle.tme_bus_cycle_size = 0;"
	echo "      }"
	echo ""
	echo "      /* otherwise, any other error might be a bus error: */"
	echo "      else if (err != TME_OK) {"
	echo ""
	echo "        /* if a real bus error may have happened, instead of"
	echo "           some synchronous event: */"
	echo "        if (err != TME_BUS_CYCLE_SYNCHRONOUS_EVENT) {"
	echo ""
	echo "          /* call the bus fault handlers: */"
	echo "          err = tme_bus_tlb_fault(&dtlb->tme_sparc_tlb_bus_tlb, &cycle, err);"
	echo "        }"
	echo ""
	echo "        /* if some synchronous event has happened: */"
	echo "        if (err == TME_BUS_CYCLE_SYNCHRONOUS_EVENT) {"
	echo ""
	echo "          /* after the currently executing instruction finishes, check"
	echo "             for external resets, halts, or interrupts: */"
	echo "          ic->_tme_sparc_instruction_burst_remaining = 0;"
	echo "        }"
	echo ""
	echo "        /* otherwise, if a real bus fault happened: */"
	echo "        else if (err != TME_OK) {"
	echo "          trap = (*ic->_tme_sparc_bus_fault)(ic, &cycle, flags, err);"
	echo "          if (trap != TME_SPARC_TRAP_none) {"
	echo "            break;"
	echo "          }"
	echo "        }"
	echo "      }"
	
	if test ${slow} = store; then
	    echo ""
	    echo "      /* if this was an atomic operation, and data was transferred: */"
	    echo "      if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_ATOMIC) != 0"
	    echo "                              && cycle.tme_bus_cycle_size > 0)) {"
	    echo ""
	    echo "        /* we do not support atomic operations in TLB entries that"
	    echo "           do not support both fast reads and fast writes.  assuming"
	    echo "           that all atomic operations are to regular memory, we"
	    echo "           should always get fast read and fast write TLBs.  when"
	    echo "           we do not, it should only be because the memory has been"
	    echo "           made read-only in the MMU.  the write above was supposed"
	    echo "           to cause a fault (with the instruction rerun later with"
	    echo "           a fast read and fast write TLB entry), but instead it"
	    echo "           succeeded and transferred some data.  we have modified"
	    echo "           memory and cannot recover: */"
	    echo "        abort();"
	    echo "      }"
	fi
	echo "    }"

	echo ""
	echo "    /* update: */"
	echo "    address += cycle.tme_bus_cycle_size;"
	echo "    transferred += cycle.tme_bus_cycle_size;"
	echo "  } while (transferred < size);"
       
	echo ""
	echo "  /* if we faulted, start trap processing: */"
	echo "  if (__tme_predict_false(trap != TME_SPARC_TRAP_none)) {"
	echo "    tme_sparc_tlb_unbusy(dtlb);"
	echo "    tme_sparc${arch}_trap(ic, trap);"
	echo "  }"

	echo ""
	if test ${slow} = load; then
	    echo "  return (ic->tme_sparc_memory_buffer - (address - size));"
	else
	    echo "  return ((tme_uint8_t *) TME_EMULATOR_OFF_UNDEF);"
	fi
	echo "}"
    done

    # unfix the architecture version:
    #
    if $header; then :; else
	echo ""
	echo "#undef TME_SPARC_VERSION"
	echo "#define TME_SPARC_VERSION(ic) _TME_SPARC_VERSION(ic)"
    fi

    # the sparc64 support depends on a 64-bit integer type:
    #
    if test ${arch} = 64; then
	echo ""
	echo "#endif /* TME_HAVE_INT64_T */"
    fi
done

# done:
#
exit 0
