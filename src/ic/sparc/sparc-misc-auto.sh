#! /bin/sh

# $Id: sparc-misc-auto.sh,v 1.2 2007/02/12 23:49:21 fredette Exp $

# ic/sparc/sparc-misc-auto.sh - automatically generates C code 
# for miscellaneous SPARC emulation support:

#
# Copyright (c) 2005 Matt Fredette
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#      This product includes software developed by Matt Fredette.
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

header=false

for option
do
    case $option in
    --header) header=true ;;
    esac
done

PROG=`basename $0`
cat <<EOF
/* automatically generated by $PROG, do not edit! */
EOF

# emit the register mapping macros:
if $header; then

    echo ""
    echo "/* the register mapping: */"
    echo "#define TME_SPARC_IREG_UNDEF		(-1)"
    ireg_next=0

    # all integer registers start from register number zero:
    #
    for regnum in 0 1 2 3 4 5 6 7; do
	echo "#define TME_SPARC_IREG_G${regnum}		(${ireg_next})"
	ireg_next=`expr ${ireg_next} + 1`
    done

    # all other registers start after the last register in the last
    # possible register window, plus the eight sparc64 alternate
    # globals:
    #
    ireg_base='((TME_SPARC_WINDOWS_MAX * 16) + 8)'

    # the current, next, and next-next program counter:
    #
    echo "#define TME_SPARC_IREG_PC		(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 1`
    echo "#define TME_SPARC_IREG_PC_NEXT		(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 1`
    echo "#define TME_SPARC_IREG_PC_NEXT_NEXT		(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 1`

    # the immediate register:
    #
    echo "#define TME_SPARC_IREG_IMM		(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 3`

    # the Y multiply/divide register:
    #
    echo "#define TME_SPARC_IREG_Y		(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 1`

    # the floating-point transfer registers.  since these are often
    # treated as 32-bit parts used to transfer 64- and 128-bit values,
    # this block of registers must be aligned to four.  NB that we
    # assume that ${ireg_base} is aligned to at least four:
    #
    while test `expr ${ireg_next} % 4` != 0; do ireg_next=`expr ${ireg_next} + 1`; done
    echo "#define TME_SPARC_IREG_FPX		(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 4`
    
    # the sparc32 PSR and WIM:
    #
    echo "#define tme_sparc32_ireg_psr		tme_sparc_ireg_uint32(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 1`
    echo "#define tme_sparc32_ireg_wim		tme_sparc_ireg_uint32(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 1`

    # the sparc32 TBR register, and the sparc64 TBA register:
    #
    echo "#define tme_sparc32_ireg_tbr		tme_sparc_ireg_uint32(${ireg_base} + ${ireg_next})"
    echo "#define tme_sparc64_ireg_tba		tme_sparc_ireg_uint64(${ireg_base} + ${ireg_next})"
    ireg_next=`expr ${ireg_next} + 1`

    # the sparc64 PSTATE register:
    #
    echo "#define tme_sparc64_ireg_pstate		tme_sparc_ireg_uint32((${ireg_base} + ${ireg_next}) << 1)"
    ireg_next=`expr ${ireg_next} + 1`

    # the sparc64 CCR and ASI registers:
    #
    echo "#define tme_sparc64_ireg_ccr		tme_sparc_ireg_uint8(((${ireg_base} + ${ireg_next}) << 3) + 0)"
    echo "#define tme_sparc64_ireg_asi		tme_sparc_ireg_uint8(((${ireg_base} + ${ireg_next}) << 3) + 1)"
    ireg_next=`expr ${ireg_next} + 1`
fi

# emit the integer condition codes->conditions mapping.  note that the
# nesting of the flag variables is deliberate, to make this array
# indexable with the condition codes value:
#
if $header; then :; else
    echo ""
    echo "/* the icc->conditions mapping: */"
    echo "const tme_uint8_t _tme_sparc_conds_icc[16] = {"
    for nflag in 0 1; do
	for zflag in 0 1; do
	    for vflag in 0 1; do
		for cflag in 0 1; do

		    # the Never condition:
		    #
		    echo -n "  0"
		    
		    # the Equal condition:
		    #
		    if test $zflag = 1; then
			echo -n "  | TME_BIT(1)"
		    fi
			
		    # the Less or Equal condition:
		    #
		    if test $zflag = 1 || test $nflag != $vflag; then
			echo -n "  | TME_BIT(2)"
		    fi

		    # the Less condition:
		    #
		    if test $nflag != $vflag; then
			echo -n "  | TME_BIT(3)"
		    fi

		    # the Less or Equal Unsigned condition:
		    #
		    if test $cflag = 1 || test $zflag = 1; then
			echo -n "  | TME_BIT(4)"
		    fi

		    # the Carry Set condition:
		    #
		    if test $cflag = 1; then
			echo -n "  | TME_BIT(5)"
		    fi

		    # the Negative condition:
		    #
		    if test $nflag = 1; then
			echo -n "  | TME_BIT(6)"
		    fi

		    # the Overflow Set condition:
		    #
		    if test $vflag = 1; then
			echo -n "  | TME_BIT(7)"
		    fi

		    echo ","
		done
	    done
	done
    done
    echo "};"
fi

# done:
#
exit 0
