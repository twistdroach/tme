/* automatically generated by sparc-insns-auto.sh, do not edit! */
_TME_RCSID("$Id: sparc-insns-auto.sh,v 1.5 2007/03/29 01:16:09 fredette Exp $");

#include "sparc-impl.h"

#undef TME_SPARC_VERSION
#define TME_SPARC_VERSION(ic) (8)
static tme_uint32_t
_tme_sparc32_alternate_asi_mask(struct tme_sparc *ic)
{
  unsigned int asi_data;
  tme_uint32_t asi_mask_data;

  /* get the ASI, assuming that the i bit is zero: */
  asi_data = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, (0xff << 5));

  /* this is a privileged instruction: */
  TME_SPARC_INSN_PRIV;

  /* if the i bit is one, this is an illegal instruction: */
  if (__tme_predict_false(TME_SPARC_INSN & TME_BIT(13))) {
    TME_SPARC_INSN_ILL;
  }

  /* map the ASI into an ASI mask: */
  switch (asi_data) {
  case TME_SPARC32_ASI_UI: asi_mask_data = TME_SPARC32_ASI_MASK_UI; break;
  case TME_SPARC32_ASI_UD: asi_mask_data = TME_SPARC32_ASI_MASK_UD; break;
  case TME_SPARC32_ASI_SI: asi_mask_data = TME_SPARC32_ASI_MASK_SI; break;
  case TME_SPARC32_ASI_SD: asi_mask_data = TME_SPARC32_ASI_MASK_SD; break;
  default: asi_mask_data = TME_SPARC_ASI_MASK(asi_data); break;
  }

  return (asi_mask_data);
}

/* this does a sparc32 "add SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_add, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 + src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "addcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_addcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 + src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are the same sign, and the destination has
     a different sign, set V: */
  cc += ((((tme_int32_t) ((src2 ^ dst) & (src1 ^ (src2 ^ (((tme_uint32_t) 0) - 1))))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src1 and src2 both have the high bit set, or if dst does
     not have the high bit set and either src1 or src2 does, set C: */
  cc += (((tme_int32_t) (((tme_uint32_t) (src1 & src2)) | ((((tme_uint32_t) dst) ^ (((tme_uint32_t) 0) - 1)) & ((tme_uint32_t) (src1 | src2))))) < 0) * TME_SPARC32_PSR_ICC_C;

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "sub SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_sub, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 - src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "subcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_subcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 - src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are different signs, and the destination has
     a different sign from the first operand, set V: */
  cc += ((((tme_int32_t) ((src1 ^ src2) & (src1 ^ dst))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src2 is greater than src1, set C: */
  cc += ((((tme_uint32_t) src2) > ((tme_uint32_t) src1))) * TME_SPARC32_PSR_ICC_C;

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "or SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_or, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 | src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "orcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_orcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 | src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "orn SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_orn, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 | ~src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "orncc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_orncc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 | ~src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "and SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_and, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 & src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "andcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_andcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 & src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "andn SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_andn, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 & ~src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "andncc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_andncc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 & ~src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "xor SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_xor, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 ^ src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "xorcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_xorcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 ^ src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "xnor SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_xnor, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 ^ ~src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "xnorcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_xnorcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 ^ ~src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "addx SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_addx, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 + src2;
  dst += ((ic->tme_sparc32_ireg_psr & TME_SPARC32_PSR_ICC_C) != 0);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "addxcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_addxcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 + src2;
  dst += ((ic->tme_sparc32_ireg_psr & TME_SPARC32_PSR_ICC_C) != 0);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are the same sign, and the destination has
     a different sign, set V: */
  cc += ((((tme_int32_t) ((src2 ^ dst) & (src1 ^ (src2 ^ (((tme_uint32_t) 0) - 1))))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src1 and src2 both have the high bit set, or if dst does
     not have the high bit set and either src1 or src2 does, set C: */
  cc += (((tme_int32_t) (((tme_uint32_t) (src1 & src2)) | ((((tme_uint32_t) dst) ^ (((tme_uint32_t) 0) - 1)) & ((tme_uint32_t) (src1 | src2))))) < 0) * TME_SPARC32_PSR_ICC_C;

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "subx SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_subx, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 - src2;
  dst -= ((ic->tme_sparc32_ireg_psr & TME_SPARC32_PSR_ICC_C) != 0);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "subxcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_subxcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 - src2;
  dst -= ((ic->tme_sparc32_ireg_psr & TME_SPARC32_PSR_ICC_C) != 0);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are different signs, and the destination has
     a different sign from the first operand, set V: */
  cc += ((((tme_int32_t) ((src1 ^ src2) & (src1 ^ dst))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src2 is greater than src1, set C: */
  cc += ((((tme_uint32_t) src2) > ((tme_uint32_t) src1)) || (((tme_uint32_t) src2) == ((tme_uint32_t) src1) && (ic->tme_sparc32_ireg_psr & TME_SPARC32_PSR_ICC_C))) * TME_SPARC32_PSR_ICC_C;

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "taddcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_taddcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 + src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are the same sign, and the destination has
     a different sign, set V: */
  cc += ((((tme_int32_t) ((src2 ^ dst) & (src1 ^ (src2 ^ (((tme_uint32_t) 0) - 1))))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src1 and src2 both have the high bit set, or if dst does
     not have the high bit set and either src1 or src2 does, set C: */
  cc += (((tme_int32_t) (((tme_uint32_t) (src1 & src2)) | ((((tme_uint32_t) dst) ^ (((tme_uint32_t) 0) - 1)) & ((tme_uint32_t) (src1 | src2))))) < 0) * TME_SPARC32_PSR_ICC_C;

  /* set V if bits zero or one of src1 or src2 are set: */
  cc |= ((((src1 | src2) & 3) != 0) * TME_SPARC32_PSR_ICC_V);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "taddcctv SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_taddcctv, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 + src2;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are the same sign, and the destination has
     a different sign, set V: */
  cc += ((((tme_int32_t) ((src2 ^ dst) & (src1 ^ (src2 ^ (((tme_uint32_t) 0) - 1))))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src1 and src2 both have the high bit set, or if dst does
     not have the high bit set and either src1 or src2 does, set C: */
  cc += (((tme_int32_t) (((tme_uint32_t) (src1 & src2)) | ((((tme_uint32_t) dst) ^ (((tme_uint32_t) 0) - 1)) & ((tme_uint32_t) (src1 | src2))))) < 0) * TME_SPARC32_PSR_ICC_C;

  /* set V if bits zero or one of src1 or src2 are set: */
  cc |= ((((src1 | src2) & 3) != 0) * TME_SPARC32_PSR_ICC_V);

  /* trap on a tagged overflow: */
  if (cc & TME_SPARC32_PSR_ICC_V) {
    tme_sparc32_trap(ic, TME_SPARC_TRAP_tag_overflow);
  }
  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "tsubcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_tsubcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 - src2;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are different signs, and the destination has
     a different sign from the first operand, set V: */
  cc += ((((tme_int32_t) ((src1 ^ src2) & (src1 ^ dst))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src2 is greater than src1, set C: */
  cc += ((((tme_uint32_t) src2) > ((tme_uint32_t) src1))) * TME_SPARC32_PSR_ICC_C;

  /* set V if bits zero or one of src1 or src2 are set: */
  cc |= ((((src1 | src2) & 3) != 0) * TME_SPARC32_PSR_ICC_V);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "tsubcctv SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_tsubcctv, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  dst = src1 - src2;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are different signs, and the destination has
     a different sign from the first operand, set V: */
  cc += ((((tme_int32_t) ((src1 ^ src2) & (src1 ^ dst))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src2 is greater than src1, set C: */
  cc += ((((tme_uint32_t) src2) > ((tme_uint32_t) src1))) * TME_SPARC32_PSR_ICC_C;

  /* set V if bits zero or one of src1 or src2 are set: */
  cc |= ((((src1 | src2) & 3) != 0) * TME_SPARC32_PSR_ICC_V);

  /* trap on a tagged overflow: */
  if (cc & TME_SPARC32_PSR_ICC_V) {
    tme_sparc32_trap(ic, TME_SPARC_TRAP_tag_overflow);
  }
  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "umul SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_umul, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint64_t val64;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = (((tme_uint64_t) src1) * src2);
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y) = (((tme_uint64_t) val64) >> 32);
  dst = ((tme_uint64_t) val64);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "umulcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_umulcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint64_t val64;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = (((tme_uint64_t) src1) * src2);
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y) = (((tme_uint64_t) val64) >> 32);
  dst = ((tme_uint64_t) val64);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "smul SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_smul, tme_uint32_t)
{
  tme_int32_t src1;
  tme_int32_t src2;
  tme_int32_t dst;
  tme_int64_t val64;

  /* get the operands: */
  src1 = (tme_int32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_int32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = (((tme_int64_t) src1) * src2);
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y) = (((tme_uint64_t) val64) >> 32);
  dst = ((tme_int64_t) val64);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_int32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "smulcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_smulcc, tme_uint32_t)
{
  tme_int32_t src1;
  tme_int32_t src2;
  tme_int32_t dst;
  tme_int64_t val64;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_int32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_int32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = (((tme_int64_t) src1) * src2);
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y) = (((tme_uint64_t) val64) >> 32);
  dst = ((tme_int64_t) val64);

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_int32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "udiv SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_udiv, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint64_t val64;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = ((((tme_uint64_t) ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y)) << 32) | ((tme_uint32_t) src1));
  val64 /= src2;
  /* XXX FIXME - overflow handling is missing here: */
  dst = val64;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "udivcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_udivcc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint64_t val64;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = ((((tme_uint64_t) ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y)) << 32) | ((tme_uint32_t) src1));
  val64 /= src2;
  /* XXX FIXME - overflow handling is missing here: */
  dst = val64;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "sdiv SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_sdiv, tme_uint32_t)
{
  tme_int32_t src1;
  tme_int32_t src2;
  tme_int32_t dst;
  tme_int64_t val64;

  /* get the operands: */
  src1 = (tme_int32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_int32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = ((((tme_uint64_t) ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y)) << 32) | ((tme_uint32_t) src1));
  val64 /= src2;
  /* XXX FIXME - overflow handling is missing here: */
  dst = val64;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_int32_t) dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "sdivcc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_sdivcc, tme_uint32_t)
{
  tme_int32_t src1;
  tme_int32_t src2;
  tme_int32_t dst;
  tme_int64_t val64;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_int32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_int32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */
  val64 = ((((tme_uint64_t) ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y)) << 32) | ((tme_uint32_t) src1));
  val64 /= src2;
  /* XXX FIXME - overflow handling is missing here: */
  dst = val64;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_int32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* the sparc32 sll function: */
TME_SPARC_FORMAT3(tme_sparc32_sll, tme_uint32_t)
{
  tme_uint32_t dst;
  unsigned int count;

  /* get the value and the shift count: */
  dst = TME_SPARC_FORMAT3_RS1;
  count = TME_SPARC_FORMAT3_RS2;

  /* limit the count: */
  count %= 32;

  /* do the shift: */
#if (SHIFTMAX_INT32_T < (32 - 1))
#error "cannot do full shifts of a tme_int32_t"
#endif /* (SHIFTMAX_INT32_T < (32 - 1)) */
  dst <<= count;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = dst;

  TME_SPARC_INSN_OK;
}

/* the sparc32 srl function: */
TME_SPARC_FORMAT3(tme_sparc32_srl, tme_uint32_t)
{
  tme_uint32_t dst;
  unsigned int count;

  /* get the value and the shift count: */
  dst = TME_SPARC_FORMAT3_RS1;
  count = TME_SPARC_FORMAT3_RS2;

  /* limit the count: */
  count %= 32;

  /* do the shift: */
#if (SHIFTMAX_INT32_T < (32 - 1))
#error "cannot do full shifts of a tme_int32_t"
#endif /* (SHIFTMAX_INT32_T < (32 - 1)) */
  dst >>= count;

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = dst;

  TME_SPARC_INSN_OK;
}

/* the sparc32 sra function: */
TME_SPARC_FORMAT3(tme_sparc32_sra, tme_uint32_t)
{
  tme_int32_t dst;
  unsigned int count;

  /* get the value and the shift count: */
  dst = TME_SPARC_FORMAT3_RS1;
  count = TME_SPARC_FORMAT3_RS2;

  /* limit the count: */
  count %= 32;

  /* do the shift: */
#ifdef SHIFTSIGNED_INT32_T
#if (SHIFTMAX_INT32_T < (32 - 1))
#error "cannot do full shifts of a tme_int32_t"
#endif /* (SHIFTMAX_INT32_T < (32 - 1)) */
  dst >>= count;
#else  /* !SHIFTSIGNED_INT32_T */
  for (; count-- > 0; ) {
    dst = (dst & ~((tme_int32_t) 1)) / 2;
  }
#endif /* !SHIFTSIGNED_INT32_T */

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = dst;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldb: */
TME_SPARC_FORMAT3(tme_sparc32_ldb, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((8 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               ((8 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read8((const tme_shared tme_uint8_t *) memory, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* possibly sign-extend the loaded value: */
  if (TME_SPARC_INSN & TME_BIT(22)) {
    value = (tme_uint32_t) (tme_int32_t) (tme_int8_t) value;
  }

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem8(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint8_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldb\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 stb: */
TME_SPARC_FORMAT3(tme_sparc32_stb, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem8(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint8_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("stb\t0x%02x:0x%08x:\t0x%02x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                (tme_uint8_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((8 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               ((8 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = (TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write8((tme_shared tme_uint8_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldh: */
TME_SPARC_FORMAT3(tme_sparc32_ldh, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((16 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (16 / 8)) != 0)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               ((16 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read16((const tme_shared tme_uint16_t *) memory, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint16_t), sizeof(tme_uint32_t));
  value = tme_betoh_u16(value);

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* possibly sign-extend the loaded value: */
  if (TME_SPARC_INSN & TME_BIT(22)) {
    value = (tme_uint32_t) (tme_int32_t) (tme_int16_t) value;
  }

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem16(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint16_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldh\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 sth: */
TME_SPARC_FORMAT3(tme_sparc32_sth, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem16(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint16_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("sth\t0x%02x:0x%08x:\t0x%04x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                (tme_uint16_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((16 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (16 / 8)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               ((16 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u16(TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write16((tme_shared tme_uint16_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint16_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ld: */
TME_SPARC_FORMAT3(tme_sparc32_ld, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((32 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (32 / 8)) != 0)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               ((32 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read32((const tme_shared tme_uint32_t *) memory, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));
  value = tme_betoh_u32(value);

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem32(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ld\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 st: */
TME_SPARC_FORMAT3(tme_sparc32_st, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem32(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("st\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((32 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (32 / 8)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               ((32 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write32((tme_shared tme_uint32_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldd: */
TME_SPARC_FORMAT3(tme_sparc32_ldd, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((64 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (64 / 8)) != 0)

                          /* the destination register number is odd: */
                          || ((TME_SPARC_INSN & TME_BIT(25)) != 0)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               ((64 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read32(((const tme_shared tme_uint32_t *) memory) + 0, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t) * 2, sizeof(tme_uint32_t));
  TME_SPARC_FORMAT3_RD = tme_betoh_u32(value);
  value = tme_memory_bus_read32(((const tme_shared tme_uint32_t *) memory) + 1, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));
  TME_SPARC_FORMAT3_RD_ODD = tme_betoh_u32(value);

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* log the value loaded: */
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldd\t0x%02x:0x%08x:\t0x%08x 0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD_ODD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 std: */
TME_SPARC_FORMAT3(tme_sparc32_std, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the values stored: */
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("std\t0x%02x:0x%08x:\t0x%08x 0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD_ODD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((64 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (64 / 8)) != 0)

                          /* the destination register number is odd: */
                          || ((TME_SPARC_INSN & TME_BIT(25)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               ((64 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write32(((tme_shared tme_uint32_t *) memory) + 0, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t) * 2, sizeof(tme_uint32_t));
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD_ODD);
  tme_memory_bus_write32(((tme_shared tme_uint32_t *) memory) + 1, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldstub: */
TME_SPARC_FORMAT3(tme_sparc32_ldstub, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((8 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory != dtlb->tme_sparc_tlb_emulator_off_read)
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_ATOMIC
                                | (8 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_atomic_xchg8(memory, 0xff, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* possibly sign-extend the loaded value: */
  if (TME_SPARC_INSN & TME_BIT(22)) {
    value = (tme_uint32_t) (tme_int32_t) (tme_int8_t) value;
  }

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem8(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint8_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldstub\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldstuba: */
TME_SPARC_FORMAT3(tme_sparc32_ldstuba, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((8 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory != dtlb->tme_sparc_tlb_emulator_off_read)
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_ATOMIC
                                | TME_SPARC_SLOW_FLAG_A
                                | (8 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_atomic_xchg8(memory, 0xff, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* possibly sign-extend the loaded value: */
  if (TME_SPARC_INSN & TME_BIT(22)) {
    value = (tme_uint32_t) (tme_int32_t) (tme_int8_t) value;
  }

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem8(ic, asi_mask_data, address, (tme_uint8_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldstuba\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 swap: */
TME_SPARC_FORMAT3(tme_sparc32_swap, tme_uint32_t)
{
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem32(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("swap\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((32 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, ic->tme_sparc_asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory != dtlb->tme_sparc_tlb_emulator_off_read)
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (32 / 8)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_ATOMIC
                                | (32 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);
  value = tme_memory_atomic_xchg32((tme_shared tme_uint32_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem32(ic, ic->tme_sparc_asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("swap\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(ic->tme_sparc_asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 swapa: */
TME_SPARC_FORMAT3(tme_sparc32_swapa, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem32(ic, asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("swapa\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((32 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory != dtlb->tme_sparc_tlb_emulator_off_read)
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (32 / 8)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_ATOMIC
                                | TME_SPARC_SLOW_FLAG_A
                                | (32 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);
  value = tme_memory_atomic_xchg32((tme_shared tme_uint32_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem32(ic, asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("swapa\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldba: */
TME_SPARC_FORMAT3(tme_sparc32_ldba, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((8 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               (TME_SPARC_SLOW_FLAG_A
                                | (8 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read8((const tme_shared tme_uint8_t *) memory, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* possibly sign-extend the loaded value: */
  if (TME_SPARC_INSN & TME_BIT(22)) {
    value = (tme_uint32_t) (tme_int32_t) (tme_int8_t) value;
  }

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem8(ic, asi_mask_data, address, (tme_uint8_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldba\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 stba: */
TME_SPARC_FORMAT3(tme_sparc32_stba, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem8(ic, asi_mask_data, address, (tme_uint8_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("stba\t0x%02x:0x%08x:\t0x%02x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                (tme_uint8_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((8 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_A
                                | (8 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = (TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write8((tme_shared tme_uint8_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint8_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldha: */
TME_SPARC_FORMAT3(tme_sparc32_ldha, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((16 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (16 / 8)) != 0)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               (TME_SPARC_SLOW_FLAG_A
                                | (16 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read16((const tme_shared tme_uint16_t *) memory, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint16_t), sizeof(tme_uint32_t));
  value = tme_betoh_u16(value);

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* possibly sign-extend the loaded value: */
  if (TME_SPARC_INSN & TME_BIT(22)) {
    value = (tme_uint32_t) (tme_int32_t) (tme_int16_t) value;
  }

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem16(ic, asi_mask_data, address, (tme_uint16_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldha\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 stha: */
TME_SPARC_FORMAT3(tme_sparc32_stha, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem16(ic, asi_mask_data, address, (tme_uint16_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("stha\t0x%02x:0x%08x:\t0x%04x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                (tme_uint16_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((16 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (16 / 8)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_A
                                | (16 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u16(TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write16((tme_shared tme_uint16_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint16_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 lda: */
TME_SPARC_FORMAT3(tme_sparc32_lda, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((32 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (32 / 8)) != 0)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               (TME_SPARC_SLOW_FLAG_A
                                | (32 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read32((const tme_shared tme_uint32_t *) memory, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));
  value = tme_betoh_u32(value);

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* set the loaded value: */
  TME_SPARC_FORMAT3_RD = value;

  /* log the value loaded: */
  tme_sparc_verify_mem32(ic, asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_READ);
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("lda\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                TME_SPARC_FORMAT3_RD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 sta: */
TME_SPARC_FORMAT3(tme_sparc32_sta, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the value stored: */
  tme_sparc_verify_mem32(ic, asi_mask_data, address, (tme_uint32_t) TME_SPARC_FORMAT3_RD, TME_BUS_CYCLE_WRITE);
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("sta\t0x%02x:0x%08x:\t0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((32 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (32 / 8)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_A
                                | (32 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write32((tme_shared tme_uint32_t *) memory, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldda: */
TME_SPARC_FORMAT3(tme_sparc32_ldda, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  const tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_read;

  /* we must call the slow load function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((64 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (64 / 8)) != 0)

                          /* the destination register number is odd: */
                          || ((TME_SPARC_INSN & TME_BIT(25)) != 0)

                          )) {

    /* call the slow load function: */
    memory = tme_sparc32_load(ic,
                               address,
                               (TME_SPARC_SLOW_FLAG_A
                                | (64 / 8)));
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_memory_bus_read32(((const tme_shared tme_uint32_t *) memory) + 0, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t) * 2, sizeof(tme_uint32_t));
  TME_SPARC_FORMAT3_RD = tme_betoh_u32(value);
  value = tme_memory_bus_read32(((const tme_shared tme_uint32_t *) memory) + 1, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));
  TME_SPARC_FORMAT3_RD_ODD = tme_betoh_u32(value);

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  /* log the value loaded: */
  tme_sparc_log(ic, 1000, TME_OK,
               (TME_SPARC_LOG_HANDLE(ic),
                _("ldda\t0x%02x:0x%08x:\t0x%08x 0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD_ODD));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 stda: */
TME_SPARC_FORMAT3(tme_sparc32_stda, tme_uint32_t)
{
  tme_uint32_t asi_mask_data;
  tme_uint32_t address;
  struct tme_sparc_tlb *dtlb;
  tme_shared tme_uint8_t *memory;
  tme_uint32_t value;

  /* get the alternate ASI mask: */
  asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);

  /* get the address: */
  address = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;

#ifdef _TME_SPARC_STATS
  /* track statistics: */
  ic->tme_sparc_stats.tme_sparc_stats_memory_total++;
#endif /* _TME_SPARC_STATS */

  /* log the values stored: */
  tme_sparc_log(ic, 1000, TME_OK, 
               (TME_SPARC_LOG_HANDLE(ic),
                _("stda\t0x%02x:0x%08x:\t0x%08x 0x%08x"),
                TME_SPARC_ASI_MASK_WHICH(asi_mask_data),
                address,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD,
                (tme_uint32_t) TME_SPARC_FORMAT3_RD_ODD));

  /* get and busy the DTLB entry: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);
  tme_sparc_tlb_busy(dtlb);

  /* assume that this DTLB applies and allows fast transfers: */
  memory = dtlb->tme_sparc_tlb_emulator_off_write;

  /* we must call the slow store function if: */
  if (__tme_predict_false(

                          /* the DTLB entry is invalid: */
                          tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)

                          /* the DTLB entry does not cover the needed addresses: */
                          || (dtlb->tme_sparc_tlb_addr_first > address)
                          || (dtlb->tme_sparc_tlb_addr_last < (address + ((64 / 8) - 1)))

                          /* the DTLB entry does not cover the needed address space: */
                          || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))

                          /* the DTLB entry does not allow fast transfers: */
                          || (memory == TME_EMULATOR_OFF_UNDEF)

                          /* the address is misaligned: */
                          || ((address % (64 / 8)) != 0)

                          /* the destination register number is odd: */
                          || ((TME_SPARC_INSN & TME_BIT(25)) != 0)

                          )) {

    /* call the slow store function: */
    memory = tme_sparc32_store(ic,
                               address,
                               &TME_SPARC_FORMAT3_RD,
                               (TME_SPARC_SLOW_FLAG_A
                                | (64 / 8)));

    /* if the slow store function did the transfer, return now: */
    if (__tme_predict_false(memory == TME_EMULATOR_OFF_UNDEF)) {
      tme_sparc_tlb_unbusy(dtlb);
      TME_SPARC_INSN_OK;
    }
  }

  /* do the fast transfer: */
  memory += address;
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD);
  tme_memory_bus_write32(((tme_shared tme_uint32_t *) memory) + 0, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t) * 2, sizeof(tme_uint32_t));
  value = tme_htobe_u32(TME_SPARC_FORMAT3_RD_ODD);
  tme_memory_bus_write32(((tme_shared tme_uint32_t *) memory) + 1, value, dtlb->tme_sparc_tlb_bus_rwlock, sizeof(tme_uint32_t), sizeof(tme_uint32_t));

  /* unbusy the DTLB entry: */
  tme_sparc_tlb_unbusy(dtlb);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 jmpl: */
TME_SPARC_FORMAT3(tme_sparc32_jmpl, tme_uint32_t)
{
  tme_uint32_t pc_next_next;

  /* "The JMPL instruction causes a register-indirect delayed control
     transfer to the address given by r[rs1] + r[rs2] if the i field is
     zero, or r[rs1] + sign_ext(simm13) if the i field is one. The JMPL
     instruction copies the PC, which contains the address of the JMPL
     instruction, into register r[rd]. If either of the low-order two
     bits of the jump address is nonzero, a mem_address_not_aligned
     trap occurs." */

  pc_next_next = TME_SPARC_FORMAT3_RS1 + TME_SPARC_FORMAT3_RS2;
  if (__tme_predict_false((pc_next_next % sizeof(tme_uint32_t)) != 0)) {
    TME_SPARC_INSN_TRAP(TME_SPARC_TRAP_mem_address_not_aligned);
  }

  /* write the PC of the jmpl into r[rd]: */
  TME_SPARC_FORMAT3_RD = ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_PC);

  /* log an indirect call instruction, which has 15 (%o7) for rd: */
  if (TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD) == 15) {
    tme_sparc_log(ic, 250, TME_OK,
                  (TME_SPARC_LOG_HANDLE(ic),
                   _("call 0x%08x"),
                   pc_next_next));
  }

  /* log a ret or retl instruction, which has 0 (%g0) for rd,
     either 31 (%i7) or 15 (%o7) for rs1, and 8 for simm13: */
  else if ((TME_SPARC_INSN | (16 << 14))
           == ((tme_uint32_t) (0x2 << 30) | (0 << 25) | (0x38 << 19) | (31 << 14) | (0x1 << 13) | 8)) {
    tme_sparc_log(ic, 250, TME_OK,
                  (TME_SPARC_LOG_HANDLE(ic),
                   _("retl 0x%08x"),
                   pc_next_next));
  }

  /* set the delayed control transfer: */
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_PC_NEXT_NEXT) = pc_next_next;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldf: */
TME_SPARC_FORMAT3(tme_sparc32_ldf, tme_uint32_t)
{
  unsigned int fpreg_number;

  TME_SPARC_INSN_FPU;

  /* decode rd: */
  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);

  /* make sure this floating-point register is single-precision: */
  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_SINGLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);

  /* do the load: */
  tme_sparc32_ld(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX));

  /* set the floating-point register value: */
  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_format = TME_FLOAT_FORMAT_IEEE754_SINGLE;
  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_value_ieee754_single
    = ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 lddf: */
TME_SPARC_FORMAT3(tme_sparc32_lddf, tme_uint32_t)
{
  unsigned int fpreg_number;

  TME_SPARC_INSN_FPU;

  /* decode rd: */
  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);

  /* make sure rd is aligned: */
  if (!tme_sparc_fpu_fpreg_aligned(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE)) {
    fpreg_number -= 1;
  }

  /* make sure that the double floating-point register is double-precision: */
  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);

  /* do the load: */
  tme_sparc32_ldd(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX));

  /* set the double floating-point register value: */
  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_format = TME_FLOAT_FORMAT_IEEE754_DOUBLE;
  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_value_ieee754_double.tme_value64_uint32_hi
    = ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX) + 0);
  ic->tme_sparc_fpu_fpregs[fpreg_number].tme_float_value_ieee754_double.tme_value64_uint32_lo
    = ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX) + 1);

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 ldfsr: */
TME_SPARC_FORMAT3(tme_sparc32_ldfsr, tme_uint32_t)
{
  tme_uint32_t fsr;

  TME_SPARC_INSN_FPU;

  /* do the load: */
  tme_sparc32_ld(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX));

  /* update the FSR: */
  fsr = ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX);
  /* "An LDFSR instruction does not affect ftt." */
  /* "The LDFSR instruction does not affect qne." */
  fsr &= ~(TME_SPARC_FSR_VER | TME_SPARC_FSR_FTT | TME_SPARC_FSR_QNE);
  ic->tme_sparc_fpu_fsr = (ic->tme_sparc_fpu_fsr & (TME_SPARC_FSR_VER | TME_SPARC_FSR_FTT | TME_SPARC_FSR_QNE)) | fsr;

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 stf: */
TME_SPARC_FORMAT3(tme_sparc32_stf, tme_uint32_t)
{
  unsigned int fpreg_number;
  const tme_uint32_t *value_single;
  tme_uint32_t value_single_buffer;

  TME_SPARC_INSN_FPU_STORE(sizeof(tme_uint32_t));

  /* decode rd: */
  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);

  /* make sure this floating-point register is single-precision: */
  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_SINGLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);

  /* get this single floating-point register in IEEE754 single-precision format: */
  value_single = tme_ieee754_single_value_get(&ic->tme_sparc_fpu_fpregs[fpreg_number], &value_single_buffer);

  /* set the floating-point register value: */
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX) = *value_single;

  /* do the store: */
  tme_sparc32_st(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 stdf: */
TME_SPARC_FORMAT3(tme_sparc32_stdf, tme_uint32_t)
{
  unsigned int fpreg_number;
  const union tme_value64 *value_double;
  union tme_value64 value_double_buffer;

  TME_SPARC_INSN_FPU_STORE(sizeof(tme_uint32_t) * 2);

  /* decode rd: */
  fpreg_number = TME_FIELD_MASK_EXTRACTU(TME_SPARC_INSN, TME_SPARC_FORMAT3_MASK_RD);

  /* make sure rd is aligned: */
  if (!tme_sparc_fpu_fpreg_aligned(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE)) {
    fpreg_number -= 1;
  }

  /* make sure the double floating-point register is double-precision: */
  tme_sparc_fpu_fpreg_format(ic, fpreg_number, TME_IEEE754_FPREG_FORMAT_DOUBLE | TME_IEEE754_FPREG_FORMAT_BUILTIN);

  /* get this double floating-point register in IEEE754 double-precision format: */
  value_double = tme_ieee754_double_value_get(&ic->tme_sparc_fpu_fpregs[fpreg_number], &value_double_buffer);

  /* set the floating-point register value: */
  ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX) + 0)
    = value_double->tme_value64_uint32_hi;
  ic->tme_sparc_ireg_uint32((TME_SPARC_IREG_FPX) + 1)
    = value_double->tme_value64_uint32_lo;

  /* do the store: */
  tme_sparc32_std(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 stfsr: */
TME_SPARC_FORMAT3(tme_sparc32_stfsr, tme_uint32_t)
{

  TME_SPARC_INSN_FPU_STORE(sizeof(ic->tme_sparc_fpu_fsr));

  /* set the FSR value to store: */
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX) = ic->tme_sparc_fpu_fsr;

  /* do the store: */
  tme_sparc32_st(ic, _rs1, _rs2, &ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_FPX));

  TME_SPARC_INSN_OK;
}

/* this does a sparc32 "mulscc SRC1, SRC2, DST": */
TME_SPARC_FORMAT3(tme_sparc32_mulscc, tme_uint32_t)
{
  tme_uint32_t src1;
  tme_uint32_t src2;
  tme_uint32_t dst;
  tme_uint32_t y;
  tme_uint32_t cc;

  /* get the operands: */
  src1 = (tme_uint32_t) TME_SPARC_FORMAT3_RS1;
  src2 = (tme_uint32_t) TME_SPARC_FORMAT3_RS2;

  /* perform the operation: */

  /* "(1) The multiplier is established as r[rs2] if the i field is zero, or 
     sign_ext(simm13) if the i field is one."

     "(3) If the least significant bit of the Y register = 1, the shifted
     value from step (2) is added to the multiplier. If the LSB of the
     Y register = 0, then 0 is added to the shifted value from step (2)." */
  y = ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y);
  if ((y & 1) == 0) {
    src2 = 0;
  }

  /* "(6) The Y register is shifted right by one bit, with the LSB of the
     unshifted r[rs1] replacing the MSB of Y." */
  y >>= 1;
  if (src1 & 1) {
    y += 0x80000000;
  }
  ic->tme_sparc_ireg_uint32(TME_SPARC_IREG_Y) = y;

  /* "(2) A 32-bit value is computed by shifting r[rs1] right by one
     bit with (N xor V) from the PSR replacing the high-order bit.
     (This is the proper sign for the previous partial product.)" */
  src1 >>= 1;
  if (((ic->tme_sparc32_ireg_psr ^ (ic->tme_sparc32_ireg_psr * (TME_SPARC32_PSR_ICC_N / TME_SPARC32_PSR_ICC_V))) & TME_SPARC32_PSR_ICC_N) != 0) {
    src1 += 0x80000000;
  }

  /* "(4) The sum from step (3) is written into r[rd]." */
  dst = src1 + src2;

  /* "(5) The integer condition codes, icc, are updated according to the
     addition performed in step (3)." */

  /* store the destination: */
  TME_SPARC_FORMAT3_RD = (tme_uint32_t) dst;

  /* set Z if the destination is zero: */
  cc = ((dst == 0) * (TME_SPARC32_PSR_ICC_Z));

  /* set N if the destination is negative: */
  cc += ((((tme_int32_t) dst) < 0) * TME_SPARC32_PSR_ICC_N);

  /* if the operands are the same sign, and the destination has
     a different sign, set V: */
  cc += ((((tme_int32_t) ((src2 ^ dst) & (src1 ^ (src2 ^ (((tme_uint32_t) 0) - 1))))) < 0) * TME_SPARC32_PSR_ICC_V);

  /* if src1 and src2 both have the high bit set, or if dst does
     not have the high bit set and either src1 or src2 does, set C: */
  cc += (((tme_int32_t) (((tme_uint32_t) (src1 & src2)) | ((((tme_uint32_t) dst) ^ (((tme_uint32_t) 0) - 1)) & ((tme_uint32_t) (src1 | src2))))) < 0) * TME_SPARC32_PSR_ICC_C;

  /* set the condition codes: */
  ic->tme_sparc32_ireg_psr = (ic->tme_sparc32_ireg_psr & ~TME_SPARC32_PSR_ICC) | cc;

  TME_SPARC_INSN_OK;
}

/* this does a slow load: */
const tme_shared tme_uint8_t *
tme_sparc32_load(struct tme_sparc *ic, 
                  tme_uint32_t address, 
                  const unsigned int flags)
{
  unsigned int size;
  tme_uint32_t asi_mask_data;
  struct tme_sparc_tlb *dtlb;
  tme_bus_addr_t physical_address;
  int shift;
  struct tme_bus_cycle cycle;
  unsigned int transferred, resid, cycle_size;
  unsigned int trap;
  int err;

  /* get the transfer size.  we can do at most a 64-bit transfer: */
  size = (flags % (sizeof(tme_uint64_t) * 2));

  /* get the DTLB entry.  our caller has already busied it: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);

  /* if the address is not aligned: */
  if (__tme_predict_false((address & (size - 1)) != 0)) {
    tme_sparc_tlb_unbusy(dtlb);
    tme_sparc32_trap(ic, TME_SPARC_TRAP_mem_address_not_aligned);
  }

  /* if this is a ldd or a std (and not an lddf or an stdf)
     and the destination register address is odd: */
  /* NB: we detect lddf and stdf by testing bit 24 in the
     instruction word: */
  if (__tme_predict_false(size == (sizeof(tme_uint32_t) * 2)
                          && (TME_SPARC_INSN & TME_BIT(25)) != 0
                          && (TME_SPARC_INSN & TME_BIT(24)) == 0)) {
    tme_sparc_tlb_unbusy(dtlb);
    tme_sparc32_trap(ic, TME_SPARC_TRAP_illegal_instruction);
  }

  /* get the ASI and its mask: */
  asi_mask_data = ic->tme_sparc_asi_mask_data;
  if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_INSN) != 0)) {
    asi_mask_data = ic->tme_sparc_asi_mask_insn;
  }
  if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_A) != 0)) {
    asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);
  }

  /* loop until the load is completed: */
  trap = TME_SPARC_TRAP_none;
  transferred = 0;
  do {

    /* while the DTLB entry is invalid, or does not cover this address
       and address space, or if it does not allow for slow or fast reads: */
    for (; (tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)
            || (dtlb->tme_sparc_tlb_addr_first > address)
            || (dtlb->tme_sparc_tlb_addr_last < address)
            || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))
            || (dtlb->tme_sparc_tlb_emulator_off_read == TME_EMULATOR_OFF_UNDEF
                && (dtlb->tme_sparc_tlb_cycles_ok & TME_BUS_CYCLE_READ) == 0)); ) {

      /* unbusy this DTLB entry for filling: */
      tme_bus_tlb_unbusy_fill(&dtlb->tme_sparc_tlb_bus_tlb);

      /* we never fill TLB entries on the stack because we never
         callout multiple fills at the same time, so the global TLB
         entry pointer always points back to the TLB entry.  this
         also means that we do not have to call tme_bus_tlb_back()
         after the fill: */
      dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_global = &dtlb->tme_sparc_tlb_bus_tlb;

      /* reload the DTLB entry: */
      tme_sparc_callout_unlock(ic);
#ifdef _TME_SPARC_STATS
      ic->tme_sparc_stats.tme_sparc_stats_dtlb_fill++;
#endif /* _TME_SPARC_STATS */
      err = (*ic->_tme_sparc_bus_connection->tme_sparc_bus_tlb_fill)
        (ic->_tme_sparc_bus_connection,
         dtlb,
         asi_mask_data,
         address,
         TME_BUS_CYCLE_READ);
      assert (err == TME_OK);
      tme_sparc_callout_relock(ic);

      /* rebusy the DTLB entry: */
      tme_sparc_tlb_busy(dtlb);
    }

    /* if this DTLB entry allows fast reads: */
    if (__tme_predict_true(dtlb->tme_sparc_tlb_emulator_off_read != TME_EMULATOR_OFF_UNDEF)) {

      /* if we have not transferred anything yet, and this
         DTLB entry covers all of the addresses and allows
         fast transfers: */
      if (__tme_predict_true(transferred == 0
                             && dtlb->tme_sparc_tlb_addr_last >= address + (size - 1)
)) {

        /* return and let our caller do the transfer: */
        return (dtlb->tme_sparc_tlb_emulator_off_read);
      }

      /* calculate the cycle size: */
      cycle_size = (dtlb->tme_sparc_tlb_addr_last - address) + 1;
      cycle_size = TME_MIN(cycle_size, sizeof(tme_uint32_t) - (address % sizeof(tme_uint32_t)));
      cycle_size = TME_MIN(cycle_size, size - transferred);
      cycle.tme_bus_cycle_size = cycle_size;

      /* do a read: */
      tme_memory_bus_read_buffer((dtlb->tme_sparc_tlb_emulator_off_read + address),
                                    (&ic->tme_sparc_memory_buffer[0] + transferred),
                                    cycle_size,
                                    dtlb->tme_sparc_tlb_bus_rwlock,
                                    sizeof(tme_uint8_t),
                                    sizeof(tme_uint32_t));
    }

    /* otherwise, this DTLB entry does not allow fast reads: */
    else {

      /* make the bus cycle structure: */
      resid = size - transferred;
      cycle.tme_bus_cycle_type = TME_BUS_CYCLE_READ;
      cycle.tme_bus_cycle_buffer = (tme_uint8_t *) (&ic->tme_sparc_memory_buffer[0] + transferred);
      cycle.tme_bus_cycle_buffer_increment = 1;
      cycle_size = TME_MIN(resid, sizeof(tme_uint32_t) - (address % sizeof(tme_uint32_t)));
      cycle.tme_bus_cycle_size = cycle_size;
      cycle.tme_bus_cycle_port = TME_BUS_CYCLE_PORT(0, TME_BUS32_LOG2);
      cycle.tme_bus_cycle_lane_routing = 
        &tme_sparc32_router[TME_SPARC_BUS_ROUTER_INDEX(TME_BUS32_LOG2, cycle_size, address)];

      /* form the physical address for the bus cycle handler: */
      physical_address = dtlb->tme_sparc_tlb_addr_offset + address;
      shift = dtlb->tme_sparc_tlb_addr_shift;
      if (shift < 0) {
        physical_address <<= (0 - shift);
      }
      else if (shift > 0) {
        physical_address >>= shift;
      }
      cycle.tme_bus_cycle_address = physical_address;

      /* callout the bus cycle: */
      tme_sparc_tlb_unbusy(dtlb);
      tme_sparc_callout_unlock(ic);
      err = (*dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_cycle)
           (dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_cycle_private, &cycle);
      tme_sparc_callout_relock(ic);
      tme_sparc_tlb_busy(dtlb);

      /* if the TLB entry was invalidated before the load: */
      if (err == EBADF
          && tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)) {
        cycle.tme_bus_cycle_size = 0;
      }

      /* otherwise, any other error might be a bus error: */
      else if (err != TME_OK) {

        /* if a real bus error may have happened, instead of
           some synchronous event: */
        if (err != TME_BUS_CYCLE_SYNCHRONOUS_EVENT) {

          /* call the bus fault handlers: */
          err = tme_bus_tlb_fault(&dtlb->tme_sparc_tlb_bus_tlb, &cycle, err);
        }

        /* if some synchronous event has happened: */
        if (err == TME_BUS_CYCLE_SYNCHRONOUS_EVENT) {

          /* after the currently executing instruction finishes, check
             for external resets, halts, or interrupts: */
          ic->_tme_sparc_instruction_burst_remaining = 0;
        }

        /* otherwise, if a real bus fault happened: */
        else if (err != TME_OK) {
          trap = (*ic->_tme_sparc_bus_fault)(ic, &cycle, flags, err);
          if (trap != TME_SPARC_TRAP_none) {
            break;
          }
        }
      }
    }

    /* update: */
    address += cycle.tme_bus_cycle_size;
    transferred += cycle.tme_bus_cycle_size;
  } while (transferred < size);

  /* if we faulted, start trap processing: */
  if (__tme_predict_false(trap != TME_SPARC_TRAP_none)) {
    tme_sparc_tlb_unbusy(dtlb);
    tme_sparc32_trap(ic, trap);
  }

  return (ic->tme_sparc_memory_buffer - (address - size));
}

/* this does a slow store: */
tme_shared tme_uint8_t *
tme_sparc32_store(struct tme_sparc *ic, 
                  tme_uint32_t address, 
                  const tme_uint32_t * const _rd,
                  const unsigned int flags)
{
  unsigned int size;
  tme_uint32_t asi_mask_data;
  struct tme_sparc_tlb *dtlb;
  tme_bus_addr_t physical_address;
  int shift;
  struct tme_bus_cycle cycle;
  unsigned int transferred, resid, cycle_size;
  unsigned int trap;
  int err;
  tme_uint32_t stored_registers[2];
  const tme_uint8_t *buffer;

  /* get the transfer size.  we can do at most a 64-bit transfer: */
  size = (flags % (sizeof(tme_uint64_t) * 2));

  /* get the DTLB entry.  our caller has already busied it: */
  dtlb = TME_SPARC_DTLB_ENTRY(ic, address);

  /* if the address is not aligned: */
  if (__tme_predict_false((address & (size - 1)) != 0)) {
    tme_sparc_tlb_unbusy(dtlb);
    tme_sparc32_trap(ic, TME_SPARC_TRAP_mem_address_not_aligned);
  }

  /* if this is a ldd or a std (and not an lddf or an stdf)
     and the destination register address is odd: */
  /* NB: we detect lddf and stdf by testing bit 24 in the
     instruction word: */
  if (__tme_predict_false(size == (sizeof(tme_uint32_t) * 2)
                          && (TME_SPARC_INSN & TME_BIT(25)) != 0
                          && (TME_SPARC_INSN & TME_BIT(24)) == 0)) {
    tme_sparc_tlb_unbusy(dtlb);
    tme_sparc32_trap(ic, TME_SPARC_TRAP_illegal_instruction);
  }

  /* get the ASI and its mask: */
  asi_mask_data = ic->tme_sparc_asi_mask_data;
  if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_INSN) != 0)) {
    asi_mask_data = ic->tme_sparc_asi_mask_insn;
  }
  if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_A) != 0)) {
    asi_mask_data = _tme_sparc32_alternate_asi_mask(ic);
  }

  /* store big-endian versions of the registers to store in
     a buffer.  we always assume that this is a std and copy
     r[rd] and r[rd + 1] into the buffer: */
  stored_registers[0] = tme_htobe_u32(TME_SPARC_FORMAT3_RD);
  stored_registers[1] = tme_htobe_u32(TME_SPARC_FORMAT3_RD_ODD);

  /* make the initial pointer into the buffer: */
  buffer = (const tme_uint8_t *) stored_registers;
  if (size < sizeof(tme_uint32_t)) {
    buffer += sizeof(tme_uint32_t) - size;
  }

  /* loop until the store is completed: */
  trap = TME_SPARC_TRAP_none;
  transferred = 0;
  do {

    /* while the DTLB entry is invalid, or does not cover this address
       and address space, or if it does not allow for slow or fast writes: */
    for (; (tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)
            || (dtlb->tme_sparc_tlb_addr_first > address)
            || (dtlb->tme_sparc_tlb_addr_last < address)
            || (!TME_SPARC_TLB_ASI_MASK_OK(dtlb, asi_mask_data))
            || (dtlb->tme_sparc_tlb_emulator_off_write == TME_EMULATOR_OFF_UNDEF
                && (dtlb->tme_sparc_tlb_cycles_ok & TME_BUS_CYCLE_WRITE) == 0)); ) {

      /* unbusy this DTLB entry for filling: */
      tme_bus_tlb_unbusy_fill(&dtlb->tme_sparc_tlb_bus_tlb);

      /* we never fill TLB entries on the stack because we never
         callout multiple fills at the same time, so the global TLB
         entry pointer always points back to the TLB entry.  this
         also means that we do not have to call tme_bus_tlb_back()
         after the fill: */
      dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_global = &dtlb->tme_sparc_tlb_bus_tlb;

      /* reload the DTLB entry: */
      tme_sparc_callout_unlock(ic);
#ifdef _TME_SPARC_STATS
      ic->tme_sparc_stats.tme_sparc_stats_dtlb_fill++;
#endif /* _TME_SPARC_STATS */
      err = (*ic->_tme_sparc_bus_connection->tme_sparc_bus_tlb_fill)
        (ic->_tme_sparc_bus_connection,
         dtlb,
         asi_mask_data,
         address,
         TME_BUS_CYCLE_WRITE);
      assert (err == TME_OK);
      tme_sparc_callout_relock(ic);

      /* rebusy the DTLB entry: */
      tme_sparc_tlb_busy(dtlb);
    }

    /* if this DTLB entry allows fast writes: */
    if (__tme_predict_true(dtlb->tme_sparc_tlb_emulator_off_write != TME_EMULATOR_OFF_UNDEF)) {

      /* if we have not transferred anything yet, and this
         DTLB entry covers all of the addresses and allows
         fast transfers: */
      if (__tme_predict_true(transferred == 0
                             && dtlb->tme_sparc_tlb_addr_last >= address + (size - 1)

                           && ((flags & TME_SPARC_SLOW_FLAG_ATOMIC) == 0
                               || dtlb->tme_sparc_tlb_emulator_off_read == dtlb->tme_sparc_tlb_emulator_off_write))) {

        /* return and let our caller do the transfer: */
        return (dtlb->tme_sparc_tlb_emulator_off_write);
      }

      /* calculate the cycle size: */
      cycle_size = (dtlb->tme_sparc_tlb_addr_last - address) + 1;
      cycle_size = TME_MIN(cycle_size, sizeof(tme_uint32_t) - (address % sizeof(tme_uint32_t)));
      cycle_size = TME_MIN(cycle_size, size - transferred);
      cycle.tme_bus_cycle_size = cycle_size;

      /* do a write: */
      tme_memory_bus_write_buffer((dtlb->tme_sparc_tlb_emulator_off_write + address),
                                    (buffer + transferred),
                                    cycle_size,
                                    dtlb->tme_sparc_tlb_bus_rwlock,
                                    sizeof(tme_uint8_t),
                                    sizeof(tme_uint32_t));
    }

    /* otherwise, this DTLB entry does not allow fast writes: */
    else {

      /* make the bus cycle structure: */
      resid = size - transferred;
      cycle.tme_bus_cycle_type = TME_BUS_CYCLE_WRITE;
      cycle.tme_bus_cycle_buffer = (tme_uint8_t *) (buffer + transferred);
      cycle.tme_bus_cycle_buffer_increment = 1;
      cycle_size = TME_MIN(resid, sizeof(tme_uint32_t) - (address % sizeof(tme_uint32_t)));
      cycle.tme_bus_cycle_size = cycle_size;
      cycle.tme_bus_cycle_port = TME_BUS_CYCLE_PORT(0, TME_BUS32_LOG2);
      cycle.tme_bus_cycle_lane_routing = 
        &tme_sparc32_router[TME_SPARC_BUS_ROUTER_INDEX(TME_BUS32_LOG2, cycle_size, address)];

      /* form the physical address for the bus cycle handler: */
      physical_address = dtlb->tme_sparc_tlb_addr_offset + address;
      shift = dtlb->tme_sparc_tlb_addr_shift;
      if (shift < 0) {
        physical_address <<= (0 - shift);
      }
      else if (shift > 0) {
        physical_address >>= shift;
      }
      cycle.tme_bus_cycle_address = physical_address;

      /* callout the bus cycle: */
      tme_sparc_tlb_unbusy(dtlb);
      tme_sparc_callout_unlock(ic);
      err = (*dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_cycle)
           (dtlb->tme_sparc_tlb_bus_tlb.tme_bus_tlb_cycle_private, &cycle);
      tme_sparc_callout_relock(ic);
      tme_sparc_tlb_busy(dtlb);

      /* if the TLB entry was invalidated before the store: */
      if (err == EBADF
          && tme_bus_tlb_is_invalid(&dtlb->tme_sparc_tlb_bus_tlb)) {
        cycle.tme_bus_cycle_size = 0;
      }

      /* otherwise, any other error might be a bus error: */
      else if (err != TME_OK) {

        /* if a real bus error may have happened, instead of
           some synchronous event: */
        if (err != TME_BUS_CYCLE_SYNCHRONOUS_EVENT) {

          /* call the bus fault handlers: */
          err = tme_bus_tlb_fault(&dtlb->tme_sparc_tlb_bus_tlb, &cycle, err);
        }

        /* if some synchronous event has happened: */
        if (err == TME_BUS_CYCLE_SYNCHRONOUS_EVENT) {

          /* after the currently executing instruction finishes, check
             for external resets, halts, or interrupts: */
          ic->_tme_sparc_instruction_burst_remaining = 0;
        }

        /* otherwise, if a real bus fault happened: */
        else if (err != TME_OK) {
          trap = (*ic->_tme_sparc_bus_fault)(ic, &cycle, flags, err);
          if (trap != TME_SPARC_TRAP_none) {
            break;
          }
        }
      }

      /* if this was an atomic operation, and data was transferred: */
      if (__tme_predict_false((flags & TME_SPARC_SLOW_FLAG_ATOMIC) != 0
                              && cycle.tme_bus_cycle_size > 0)) {

        /* we do not support atomic operations in TLB entries that
           do not support both fast reads and fast writes.  assuming
           that all atomic operations are to regular memory, we
           should always get fast read and fast write TLBs.  when
           we do not, it should only be because the memory has been
           made read-only in the MMU.  the write above was supposed
           to cause a fault (with the instruction rerun later with
           a fast read and fast write TLB entry), but instead it
           succeeded and transferred some data.  we have modified
           memory and cannot recover: */
        abort();
      }
    }

    /* update: */
    address += cycle.tme_bus_cycle_size;
    transferred += cycle.tme_bus_cycle_size;
  } while (transferred < size);

  /* if we faulted, start trap processing: */
  if (__tme_predict_false(trap != TME_SPARC_TRAP_none)) {
    tme_sparc_tlb_unbusy(dtlb);
    tme_sparc32_trap(ic, trap);
  }

  return ((tme_uint8_t *) TME_EMULATOR_OFF_UNDEF);
}

#undef TME_SPARC_VERSION
#define TME_SPARC_VERSION(ic) _TME_SPARC_VERSION(ic)
/* automatically generated by sparc-misc-auto.sh, do not edit! */

/* the icc->conditions mapping: */
const tme_uint8_t _tme_sparc_conds_icc[16] = {
  0,
  0  | TME_BIT(4)  | TME_BIT(5),
  0  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(7),
  0  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(4)  | TME_BIT(5)  | TME_BIT(7),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(4),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(4)  | TME_BIT(5),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(4)  | TME_BIT(7),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(4)  | TME_BIT(5)  | TME_BIT(7),
  0  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(6),
  0  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(4)  | TME_BIT(5)  | TME_BIT(6),
  0  | TME_BIT(6)  | TME_BIT(7),
  0  | TME_BIT(4)  | TME_BIT(5)  | TME_BIT(6)  | TME_BIT(7),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(4)  | TME_BIT(6),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(3)  | TME_BIT(4)  | TME_BIT(5)  | TME_BIT(6),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(4)  | TME_BIT(6)  | TME_BIT(7),
  0  | TME_BIT(1)  | TME_BIT(2)  | TME_BIT(4)  | TME_BIT(5)  | TME_BIT(6)  | TME_BIT(7),
};
