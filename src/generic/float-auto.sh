#! /bin/sh

# $Id: float-auto.sh,v 1.1 2005/02/17 12:17:00 fredette Exp $

# generic/float-auto.sh - automatically generates C code for floating
# point conversion functions:

#
# Copyright (c) 2004 Matt Fredette
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#      This product includes software developed by Matt Fredette.
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#

header=false
for option
do
    case $option in
    --header) header=true ;;
    esac
done

PROG=`basename $0`
cat <<EOF
/* automatically generated by $PROG, do not edit! */

EOF
if $header; then :; else
    cat <<EOF
#include <tme/common.h>
_TME_RCSID("\$Id: float-auto.sh,v 1.1 2005/02/17 12:17:00 fredette Exp $");

/* includes: */
#include <tme/generic/float.h>

EOF
fi

# permute over the builtin types:
#
for _builtin_type in float double long_double; do

    # make the builtin type without underscores, and in all caps:
    #
    builtin_type=`echo ${_builtin_type} | sed -e 's/_/ /g'`
    _BUILTIN_TYPE=`echo ${_builtin_type} | tr 'a-z' 'A-Z'`

    # dispatch on the builtin type to open any protection:
    #
    case ${_builtin_type} in
    long_double) 
	echo ; echo "#ifdef _TME_HAVE_${_BUILTIN_TYPE}" ;;
    *) ;;
    esac

    # permute over the radices:
    #
    for radix in 2 10; do

	# if we're generating a header:
	#
	if $header; then
	    cat <<EOF

/* this returns the radix ${radix} mantissa and exponent of an in-range ${builtin_type}.
   the mantissa is either zero, or in the range [1,${radix}): */
${builtin_type} tme_float_radix${radix}_mantissa_exponent_${_builtin_type} _TME_P((${builtin_type}, tme_int32_t *));

/* this scales a value by adding n to its radix ${radix} exponent: */
${builtin_type} tme_float_radix${radix}_scale_${_builtin_type} _TME_P((${builtin_type}, tme_int32_t));
EOF
	    continue
	fi

	# permute over the sign of the exponent:
	#
	for _sign in pos neg; do

	    # make the sign into two operators:
	    #
	    if test ${_sign} = pos; then sign= ; combine='*' ; else sign=- ; combine='/' ; fi

	    echo ""
	    echo "/* a series of ${builtin_type} values of the form ${radix}^${sign}x, where x is a power of two: */"
	    echo "static const ${builtin_type} _tme_float_radix${radix}_exponent_bits_${_builtin_type}_${_sign}[] = {"
	    exponent=1
	    formats_last=

	    while true; do

		# dispatch on the radix to get the largest factor we will
		# use, its exponent, and a coarse upper bound on this
		# value's exponent in the worst-case radix of two:
		#
		case ${radix} in
		2)  exponent_radix2=${exponent} ; x=16777216 ; exponent_x=24 ;;
		10) exponent_radix2=`expr ${exponent} \* 4` ; x=10000 ; exponent_x=4 ;;
		*) 
		    echo "$PROG internal error: can't handle radix ${radix}" 1>&2 
		    exit 1
		    ;;
		esac

		# we assume that all floating-point formats that use a
		# radix of two support at least positive and negative
		# exponents of magnitude 16.  if this exponent's
		# magnitude is greater than that, dispatch to get the
		# list of floating-point formats that support it:
		#
		formats=
		if test `expr ${exponent_radix2} \> 16` != 0; then

		    # the IEEE 754 types:
		    #
		    if test `expr ${exponent_radix2} \< 16384` != 0; then
			formats="${formats} | TME_FLOAT_FORMAT_IEEE754_EXTENDED80"
		    fi
		    if test `expr ${exponent_radix2} \< 1024` != 0; then
			formats="${formats} | TME_FLOAT_FORMAT_IEEE754_DOUBLE"
		    fi
		    if test `expr ${exponent_radix2} \< 128` != 0; then
			formats="${formats} | TME_FLOAT_FORMAT_IEEE754_SINGLE"
		    fi

		    # if we don't know any formats that support this
		    # exponent, stop now:
		    #
		    if test "x${formats}" = x; then
			break
		    fi

		    # clean up the formats:
		    #
		    formats="((TME_FLOAT_FORMAT_${_BUILTIN_TYPE} & ("`echo "${formats}" | sed -e 's%^ | %%'`")) != 0)"
		fi

		# if the formats have changed: 
		#
		if test "x${formats}" != "x${formats_last}"; then

		    # close any old #if first:
		    #
		    if test "x${formats_last}" != x; then
			echo ""
			echo "#endif /* ${formats_last} */"
		    fi

		    # open the new #if:
		    #
		    echo ""
		    echo "#if ${formats}"
		    formats_last=${formats}
		fi

		# compute this value:
		#
		echo ""
		echo "  /* ${radix}^${sign}${exponent}: */"
		exponent_remaining=${exponent}
		value=1
		while test ${exponent_remaining} != 0; do
		    if test `expr ${exponent_remaining} \>= ${exponent_x}` = 1; then
			value="(${value} ${combine} ((${builtin_type}) ((tme_uint32_t) ${x})))"
			exponent_remaining=`expr ${exponent_remaining} - ${exponent_x}`
		    else
			x=`expr ${x} / ${radix}`
			exponent_x=`expr ${exponent_x} - 1`
		    fi
		done
		echo "  ${value},"

		# double the exponent:
		#
		exponent=`expr ${exponent} \* 2`
	    done

	    # close any #if:
	    #
	    if test "x${formats_last}" != x; then
		echo ""
		echo "#endif /* ${formats_last} */"
	    fi

	    echo "};"
	done

cat <<EOF

/* this returns the radix ${radix} mantissa and exponent of an in-range ${builtin_type}.
   the mantissa is either zero, or in the range [1,${radix}): */
${builtin_type}
tme_float_radix${radix}_mantissa_exponent_${_builtin_type}(${builtin_type} value, tme_int32_t *_exponent)
{
  tme_int32_t exponent;
  tme_uint32_t exponent_bit;
  int negate;

  /* take the magnitude of the value, but remember if it was negative: */
  negate = (value < 0);
  if (negate) {
    value = 0 - value;
  }

  /* start with an exponent of zero: */
  exponent = 0;

  /* if the value is zero, return zero: */
  /* XXX FIXME this returns positive zero for a negative zero argument: */
  if (value == 0) {
    *_exponent = exponent;
    return (0);
  }

  /* while the value is less than one: */
  exponent_bit = TME_ARRAY_ELS(_tme_float_radix${radix}_exponent_bits_${_builtin_type}_neg) - 1;
  for (; value < 1; ) {

    /* if value is less than or equal to ${radix}^-(2^exponent_bit),
       divide value by ${radix}^-(2^exponent_bit), and subtract 2^exponent_bit
       from exponent: */
    if (value <= _tme_float_radix${radix}_exponent_bits_${_builtin_type}_neg[exponent_bit]
        || exponent_bit == 0) {
      value /= _tme_float_radix${radix}_exponent_bits_${_builtin_type}_neg[exponent_bit];
      exponent -= (1 << exponent_bit);
    }

    /* otherwise, move to the next exponent bit: */
    else {
      exponent_bit--;
    }
  }

  /* while the value is greater than ${radix}: */
  exponent_bit = TME_ARRAY_ELS(_tme_float_radix${radix}_exponent_bits_${_builtin_type}_pos) - 1;
  for (; value > ${radix}; ) {

    /* if value is greater than or equal to ${radix}^(2^exponent_bit),
       divide value by ${radix}^(2^exponent_bit), and add 2^exponent_bit
       to exponent: */
    if (value >= _tme_float_radix${radix}_exponent_bits_${_builtin_type}_pos[exponent_bit]
        || exponent_bit == 0) {
      value /= _tme_float_radix${radix}_exponent_bits_${_builtin_type}_pos[exponent_bit];
      exponent += (1 << exponent_bit);
    }

    /* otherwise, move to the next exponent bit: */
    else {
      exponent_bit--;
    }
  }

  /* done: */
  *_exponent = exponent;
  return (negate ? 0 - value : value);
}

/* this scales a value by adding n to its exponent: */
${builtin_type}
tme_float_radix${radix}_scale_${_builtin_type}(${builtin_type} value, tme_int32_t _n)
{
  tme_uint32_t exponent_bit, exponent;
  tme_uint32_t n;

  /* start with the most significant exponent bit: */
  exponent_bit = TME_ARRAY_ELS(_tme_float_radix${radix}_exponent_bits_${_builtin_type}_pos) - 1;
  exponent = (1 << exponent_bit);

  /* if n is negative: */
  if (_n < 0) {

    for (n = 0 - _n; n > 0;) {
      if (n >= exponent || exponent == 1) {
        value /= _tme_float_radix${radix}_exponent_bits_${_builtin_type}_pos[exponent_bit];
        n -= exponent;
      }
      else {
        exponent >>= 1;
        exponent_bit--;
      }
    }
  }

  /* otherwise, n is positive: */
  else {
    for (n = _n; n > 0;) {
      if (n >= exponent || exponent == 1) {
        value *= _tme_float_radix${radix}_exponent_bits_${_builtin_type}_pos[exponent_bit];
        n -= exponent;
      }
      else {
        exponent >>= 1;
        exponent_bit--;
      }
    }
  }

  return (value);
}
EOF
    done

    # dispatch on the type to close any protection:
    #
    case ${_builtin_type} in
    long_double) 
	echo ; echo "#endif /* _TME_HAVE_${_BUILTIN_TYPE} */" ;;
    *) ;;
    esac

done
	
# done:
#
exit 0
